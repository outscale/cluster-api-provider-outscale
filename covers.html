
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>controllers: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/outscale-dev/cluster-api-provider-outscale.git/controllers/osccluster_controller.go (4.6%)</option>
				
				<option value="file1">github.com/outscale-dev/cluster-api-provider-outscale.git/controllers/osccluster_internetservice_controller.go (100.0%)</option>
				
				<option value="file2">github.com/outscale-dev/cluster-api-provider-outscale.git/controllers/osccluster_loadbalancer_controller.go (100.0%)</option>
				
				<option value="file3">github.com/outscale-dev/cluster-api-provider-outscale.git/controllers/osccluster_natservice_controller.go (100.0%)</option>
				
				<option value="file4">github.com/outscale-dev/cluster-api-provider-outscale.git/controllers/osccluster_net_controller.go (100.0%)</option>
				
				<option value="file5">github.com/outscale-dev/cluster-api-provider-outscale.git/controllers/osccluster_publicip_controller.go (96.4%)</option>
				
				<option value="file6">github.com/outscale-dev/cluster-api-provider-outscale.git/controllers/osccluster_routetable_controller.go (100.0%)</option>
				
				<option value="file7">github.com/outscale-dev/cluster-api-provider-outscale.git/controllers/osccluster_securitygroup_controller.go (100.0%)</option>
				
				<option value="file8">github.com/outscale-dev/cluster-api-provider-outscale.git/controllers/osccluster_subnet_controller.go (100.0%)</option>
				
				<option value="file9">github.com/outscale-dev/cluster-api-provider-outscale.git/controllers/oscmachine_controller.go (0.0%)</option>
				
				<option value="file10">github.com/outscale-dev/cluster-api-provider-outscale.git/controllers/oscmachine_vm_controller.go (100.0%)</option>
				
				<option value="file11">github.com/outscale-dev/cluster-api-provider-outscale.git/controllers/oscmachine_volume_controller.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"
        "fmt"
        "time"

        infrastructurev1beta1 "github.com/outscale-dev/cluster-api-provider-outscale.git/api/v1beta1"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/scope"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/services/net"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/services/security"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/services/service"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/util/reconciler"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/client-go/tools/record"
        clusterv1 "sigs.k8s.io/cluster-api/api/v1beta1"
        "sigs.k8s.io/cluster-api/util"
        "sigs.k8s.io/cluster-api/util/annotations"
        "sigs.k8s.io/cluster-api/util/conditions"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
        "sigs.k8s.io/controller-runtime/pkg/log"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"
)

// OscClusterReconciler reconciles a OscCluster object
type OscClusterReconciler struct {
        client.Client
        Recorder         record.EventRecorder
        ReconcileTimeout time.Duration
}

//+kubebuilder:rbac:groups=infrastructure.cluster.x-k8s.io,resources=oscclusters,verbs=get;list;watch;create;update;patch;delete
//+kubebuilder:rbac:groups=infrastructure.cluster.x-k8s.io,resources=oscclusters/status,verbs=get;update;patch
//+kubebuilder:rbac:groups=infrastructure.cluster.x-k8s.io,resources=oscclusters/finalizers,verbs=update
//+kubebuilder:rbac:groups=cluster.x-k8s.io,resources=clusters,verbs=get;list;watch
//+kubebuilder:rbac:groups=cluster.x-k8s.io,resources=clusters/status,verbs=get;list;watch
//+kubebuilder:rbac:groups="",resources=secrets,verbs=get;list;watch
//+kubebuilder:rbac:groups="",resources=events,verbs=create;get;list;patch;update;watch

// getNetSvc retrieve netSvc
func (r *OscClusterReconciler) getNetSvc(ctx context.Context, scope scope.ClusterScope) net.OscNetInterface <span class="cov0" title="0">{
        return net.NewService(ctx, &amp;scope)
}</span>

// getSubnetSvc retrieve subnetSvc
func (r *OscClusterReconciler) getSubnetSvc(ctx context.Context, scope scope.ClusterScope) net.OscSubnetInterface <span class="cov0" title="0">{
        return net.NewService(ctx, &amp;scope)
}</span>

// getInternetServiceSvc retrieve internetServiceSvc
func (r *OscClusterReconciler) getInternetServiceSvc(ctx context.Context, scope scope.ClusterScope) net.OscInternetServiceInterface <span class="cov0" title="0">{
        return net.NewService(ctx, &amp;scope)
}</span>

// getRouteTableSvc retrieve routeTableSvc
func (r *OscClusterReconciler) getRouteTableSvc(ctx context.Context, scope scope.ClusterScope) security.OscRouteTableInterface <span class="cov0" title="0">{
        return security.NewService(ctx, &amp;scope)
}</span>

// getSecurityGroupSvc retrieve securityGroupSvc
func (r *OscClusterReconciler) getSecurityGroupSvc(ctx context.Context, scope scope.ClusterScope) security.OscSecurityGroupInterface <span class="cov0" title="0">{
        return security.NewService(ctx, &amp;scope)
}</span>

// getNatServiceSvc retrieve natServiceSvc
func (r *OscClusterReconciler) getNatServiceSvc(ctx context.Context, scope scope.ClusterScope) net.OscNatServiceInterface <span class="cov0" title="0">{
        return net.NewService(ctx, &amp;scope)
}</span>

// getPublicIPSvc retrieve publicIPSvc
func (r *OscClusterReconciler) getPublicIPSvc(ctx context.Context, scope scope.ClusterScope) security.OscPublicIPInterface <span class="cov0" title="0">{
        return security.NewService(ctx, &amp;scope)
}</span>

// getLoadBalancerSvc retrieve loadBalancerSvc
func (r *OscClusterReconciler) getLoadBalancerSvc(ctx context.Context, scope scope.ClusterScope) service.OscLoadBalancerInterface <span class="cov0" title="0">{
        return service.NewService(ctx, &amp;scope)
}</span>

func (r *OscClusterReconciler) Reconcile(ctx context.Context, req ctrl.Request) (_ ctrl.Result, reterr error) <span class="cov0" title="0">{
        _ = log.FromContext(ctx)
        ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultedLoopTimeout(r.ReconcileTimeout))
        defer cancel()
        log := ctrl.LoggerFrom(ctx)
        oscCluster := &amp;infrastructurev1beta1.OscCluster{}

        if err := r.Get(ctx, req.NamespacedName, oscCluster); err != nil </span><span class="cov0" title="0">{
                if apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        log.Info("object was not found")
                        return ctrl.Result{}, nil
                }</span>
                <span class="cov0" title="0">return ctrl.Result{}, err</span>
        }
        <span class="cov0" title="0">cluster, err := util.GetOwnerCluster(ctx, r.Client, oscCluster.ObjectMeta)
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov0" title="0">if cluster == nil </span><span class="cov0" title="0">{
                log.Info("Cluster Controller has not yet set OwnerRef")
                return reconcile.Result{}, nil
        }</span>

        // Return early if the object or Cluster is paused.
        <span class="cov0" title="0">if annotations.IsPaused(cluster, oscCluster) </span><span class="cov0" title="0">{
                log.Info("oscCluster or linked Cluster is marked as paused. Won't reconcile")
                return ctrl.Result{}, nil
        }</span>

        // Create the cluster scope.
        <span class="cov0" title="0">clusterScope, err := scope.NewClusterScope(scope.ClusterScopeParams{
                Client:     r.Client,
                Logger:     log,
                Cluster:    cluster,
                OscCluster: oscCluster,
        })
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, fmt.Errorf("failed to create scope: %+v", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := clusterScope.Close(); err != nil &amp;&amp; reterr == nil </span><span class="cov0" title="0">{
                        reterr = err
                }</span>
        }()
        <span class="cov0" title="0">osccluster := clusterScope.OscCluster
        if !osccluster.DeletionTimestamp.IsZero() </span><span class="cov0" title="0">{
                return r.reconcileDelete(ctx, clusterScope)
        }</span>
        <span class="cov0" title="0">loadBalancerSpec := clusterScope.GetLoadBalancer()
        loadBalancerSpec.SetDefaultValue()
        log.Info("Create loadBalancer", "loadBalancerName", loadBalancerSpec.LoadBalancerName)
        return r.reconcile(ctx, clusterScope)</span>
}

// alertDuplicate alert if item is present more than once in array
func alertDuplicate(nameArray []string) error <span class="cov8" title="1">{
        checkMap := make(map[string]bool, 0)
        for _, name := range nameArray </span><span class="cov8" title="1">{
                if checkMap[name] == true </span><span class="cov8" title="1">{
                        return fmt.Errorf("%s already exist", name)
                }</span> else<span class="cov8" title="1"> {
                        checkMap[name] = true
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// contains check if item is present in slice
func Contains(slice []string, item string) bool <span class="cov8" title="1">{
        for _, val := range slice </span><span class="cov8" title="1">{
                if val == item </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// reconcile reconcile the creation of the cluster
func (r *OscClusterReconciler) reconcile(ctx context.Context, clusterScope *scope.ClusterScope) (reconcile.Result, error) <span class="cov0" title="0">{
        clusterScope.Info("Reconcile OscCluster")
        osccluster := clusterScope.OscCluster
        controllerutil.AddFinalizer(osccluster, "oscclusters.infrastructure.cluster.x-k8s.io")
        if err := clusterScope.PatchObject(); err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, err
        }</span>
        // Check that every element of the cluster spec has the good format (CIDR, Tag, ...)
        <span class="cov0" title="0">netName, err := checkNetFormatParameters(clusterScope)
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, fmt.Errorf("%w Can not create net %s for OscCluster %s/%s", err, netName, clusterScope.GetNamespace(), clusterScope.GetName())
        }</span>
        <span class="cov0" title="0">subnetName, err := checkSubnetFormatParameters(clusterScope)
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, fmt.Errorf("%w Can not create subnet %s for OscCluster %s/%s", err, subnetName, clusterScope.GetNamespace(), clusterScope.GetName())
        }</span>

        <span class="cov0" title="0">internetServiceName, err := checkInternetServiceFormatParameters(clusterScope)
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, fmt.Errorf("%w Can not create internetService %s for OscCluster %s/%s", err, internetServiceName, clusterScope.GetNamespace(), clusterScope.GetName())
        }</span>

        <span class="cov0" title="0">publicIpName, err := checkPublicIPFormatParameters(clusterScope)
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, fmt.Errorf("%w Can not create internetService %s for OscCluster %s/%s", err, publicIpName, clusterScope.GetNamespace(), clusterScope.GetName())
        }</span>

        <span class="cov0" title="0">natName, err := checkNatFormatParameters(clusterScope)
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, fmt.Errorf("%w Can not create natService %s for OscCluster %s/%s", err, natName, clusterScope.GetNamespace(), clusterScope.GetName())
        }</span>

        <span class="cov0" title="0">routeTableName, err := checkRouteTableFormatParameters(clusterScope)
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, fmt.Errorf("%w Can not create routeTable %s for OscCluster %s/%s", err, routeTableName, clusterScope.GetNamespace(), clusterScope.GetName())
        }</span>

        <span class="cov0" title="0">securityGroupName, err := checkSecurityGroupFormatParameters(clusterScope)
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, fmt.Errorf("%w Can not create securityGroup %s for OscCluster %s/%s", err, securityGroupName, clusterScope.GetNamespace(), clusterScope.GetName())
        }</span>

        <span class="cov0" title="0">routeName, err := checkRouteFormatParameters(clusterScope)
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, fmt.Errorf("%w Can not create route %s for OscCluster %s/%s", err, routeName, clusterScope.GetNamespace(), clusterScope.GetName())
        }</span>

        <span class="cov0" title="0">securityGroupRuleName, err := checkSecurityGroupRuleFormatParameters(clusterScope)
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, fmt.Errorf("%w Can not create security group rule %s for OscCluster %s/%s", err, securityGroupRuleName, clusterScope.GetNamespace(), clusterScope.GetName())
        }</span>
        <span class="cov0" title="0">reconcileLoadBalancerName, err := checkLoadBalancerFormatParameters(clusterScope)
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, fmt.Errorf("%w Can not create loadBalancer %s for OscCluster %s/%s", err, reconcileLoadBalancerName, clusterScope.GetNamespace(), clusterScope.GetName())
        }</span>

        // Check that every element of the cluster spec has a unique tag name
        <span class="cov0" title="0">duplicateResourceRouteTableErr := checkRouteTableOscDuplicateName(clusterScope)
        if duplicateResourceRouteTableErr != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, duplicateResourceRouteTableErr
        }</span>

        <span class="cov0" title="0">duplicateResourceSecurityGroupErr := checkSecurityGroupOscDuplicateName(clusterScope)
        if duplicateResourceSecurityGroupErr != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, duplicateResourceSecurityGroupErr
        }</span>

        <span class="cov0" title="0">duplicateResourceRouteErr := checkRouteOscDuplicateName(clusterScope)
        if duplicateResourceRouteErr != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, duplicateResourceRouteErr
        }</span>

        <span class="cov0" title="0">duplicateResourceSecurityGroupRuleErr := checkSecurityGroupRuleOscDuplicateName(clusterScope)
        if duplicateResourceSecurityGroupRuleErr != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, duplicateResourceSecurityGroupRuleErr
        }</span>

        <span class="cov0" title="0">duplicateResourcePublicIpErr := checkPublicIPOscDuplicateName(clusterScope)
        if duplicateResourcePublicIpErr != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, duplicateResourcePublicIpErr
        }</span>

        <span class="cov0" title="0">duplicateResourceSubnetErr := checkSubnetOscDuplicateName(clusterScope)
        if duplicateResourceSubnetErr != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, duplicateResourceSubnetErr
        }</span>

        // Check that every element of the cluster spec which has other element depencies has the same dependencies tag name

        <span class="cov0" title="0">checkOscAssociatePublicIpErr := checkPublicIPOscAssociateResourceName(clusterScope)
        if checkOscAssociatePublicIpErr != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, checkOscAssociatePublicIpErr
        }</span>

        <span class="cov0" title="0">checkOscAssociateRouteTableSubnetErr := checkRouteTableSubnetOscAssociateResourceName(clusterScope)
        if checkOscAssociateRouteTableSubnetErr != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, checkOscAssociateRouteTableSubnetErr
        }</span>

        <span class="cov0" title="0">checkOscAssociateNatSubnetErr := checkNatSubnetOscAssociateResourceName(clusterScope)
        if checkOscAssociateNatSubnetErr != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, checkOscAssociateNatSubnetErr
        }</span>

        <span class="cov0" title="0">checkOscAssociateLoadBalancerSubnetErr := checkLoadBalancerSubnetOscAssociateResourceName(clusterScope)
        if checkOscAssociateLoadBalancerSubnetErr != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, checkOscAssociateLoadBalancerSubnetErr
        }</span>

        <span class="cov0" title="0">checkOscAssociateLoadBalancerSecurityGroupErr := checkLoadBalancerSecurityGroupOscAssociateResourceName(clusterScope)
        if checkOscAssociateLoadBalancerSecurityGroupErr != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, checkOscAssociateLoadBalancerSecurityGroupErr
        }</span>
        <span class="cov0" title="0">clusterScope.Info("Set OscCluster status to not ready")
        clusterScope.SetNotReady()
        // Reconcile each element of the cluster
        netSvc := r.getNetSvc(ctx, *clusterScope)
        reconcileNet, err := reconcileNet(ctx, clusterScope, netSvc)
        if err != nil </span><span class="cov0" title="0">{
                clusterScope.Error(err, "failed to reconcile net")
                conditions.MarkFalse(osccluster, infrastructurev1beta1.NetReadyCondition, infrastructurev1beta1.NetReconciliationFailedReason, clusterv1.ConditionSeverityWarning, err.Error())
                return reconcileNet, err
        }</span>
        <span class="cov0" title="0">conditions.MarkTrue(osccluster, infrastructurev1beta1.NetReadyCondition)

        subnetSvc := r.getSubnetSvc(ctx, *clusterScope)
        reconcileSubnets, err := reconcileSubnet(ctx, clusterScope, subnetSvc)
        if err != nil </span><span class="cov0" title="0">{
                clusterScope.Error(err, "failed to reconcile subnet")
                conditions.MarkFalse(osccluster, infrastructurev1beta1.SubnetsReadyCondition, infrastructurev1beta1.SubnetsReconciliationFailedReason, clusterv1.ConditionSeverityWarning, err.Error())
                return reconcileSubnets, err
        }</span>
        <span class="cov0" title="0">conditions.MarkTrue(osccluster, infrastructurev1beta1.SubnetsReadyCondition)

        internetServiceSvc := r.getInternetServiceSvc(ctx, *clusterScope)
        reconcileInternetService, err := reconcileInternetService(ctx, clusterScope, internetServiceSvc)
        if err != nil </span><span class="cov0" title="0">{
                clusterScope.Error(err, "failed to reconcile internetService")
                conditions.MarkFalse(osccluster, infrastructurev1beta1.InternetServicesReadyCondition, infrastructurev1beta1.InternetServicesFailedReason, clusterv1.ConditionSeverityWarning, err.Error())
                return reconcileInternetService, err
        }</span>
        <span class="cov0" title="0">conditions.MarkTrue(osccluster, infrastructurev1beta1.InternetServicesReadyCondition)

        publicIpSvc := r.getPublicIPSvc(ctx, *clusterScope)
        reconcilePublicIp, err := reconcilePublicIP(ctx, clusterScope, publicIpSvc)
        if err != nil </span><span class="cov0" title="0">{
                clusterScope.Error(err, "failed to reconcile publicIp")
                conditions.MarkFalse(osccluster, infrastructurev1beta1.PublicIPSReadyCondition, infrastructurev1beta1.PublicIPSFailedReason, clusterv1.ConditionSeverityWarning, err.Error())
                return reconcilePublicIp, err
        }</span>
        <span class="cov0" title="0">conditions.MarkTrue(osccluster, infrastructurev1beta1.PublicIPSReadyCondition)

        securityGroupSvc := r.getSecurityGroupSvc(ctx, *clusterScope)
        reconcileSecurityGroups, err := reconcileSecurityGroup(ctx, clusterScope, securityGroupSvc)
        if err != nil </span><span class="cov0" title="0">{
                clusterScope.Error(err, "failed to reconcile securityGroup")
                conditions.MarkFalse(osccluster, infrastructurev1beta1.SecurityGroupReadyCondition, infrastructurev1beta1.SecurityGroupReconciliationFailedReason, clusterv1.ConditionSeverityWarning, err.Error())
                return reconcileSecurityGroups, err
        }</span>
        <span class="cov0" title="0">conditions.MarkTrue(osccluster, infrastructurev1beta1.SecurityGroupReadyCondition)

        routeTableSvc := r.getRouteTableSvc(ctx, *clusterScope)
        reconcileRouteTables, err := reconcileRouteTable(ctx, clusterScope, routeTableSvc)
        if err != nil </span><span class="cov0" title="0">{
                clusterScope.Error(err, "failed to reconcile routeTable")
                conditions.MarkFalse(osccluster, infrastructurev1beta1.RouteTablesReadyCondition, infrastructurev1beta1.RouteTableReconciliationFailedReason, clusterv1.ConditionSeverityWarning, err.Error())
                return reconcileRouteTables, err
        }</span>
        <span class="cov0" title="0">conditions.MarkTrue(osccluster, infrastructurev1beta1.RouteTablesReadyCondition)

        natServiceSvc := r.getNatServiceSvc(ctx, *clusterScope)
        reconcileNatService, err := reconcileNatService(ctx, clusterScope, natServiceSvc)
        if err != nil </span><span class="cov0" title="0">{
                clusterScope.Error(err, "failed to reconcile natservice")
                conditions.MarkFalse(osccluster, infrastructurev1beta1.NatServicesReadyCondition, infrastructurev1beta1.NatServicesReconciliationFailedReason, clusterv1.ConditionSeverityWarning, err.Error())
                return reconcileNatService, nil
        }</span>
        <span class="cov0" title="0">conditions.MarkTrue(osccluster, infrastructurev1beta1.NatServicesReadyCondition)

        reconcileNatRouteTable, err := reconcileRouteTable(ctx, clusterScope, routeTableSvc)
        if err != nil </span><span class="cov0" title="0">{
                clusterScope.Error(err, "failed to reconcile NatRouteTable")
                conditions.MarkFalse(osccluster, infrastructurev1beta1.RouteTablesReadyCondition, infrastructurev1beta1.RouteTableReconciliationFailedReason, clusterv1.ConditionSeverityWarning, err.Error())
                return reconcileNatRouteTable, err
        }</span>
        <span class="cov0" title="0">conditions.MarkTrue(osccluster, infrastructurev1beta1.RouteTablesReadyCondition)

        loadBalancerSvc := r.getLoadBalancerSvc(ctx, *clusterScope)
        _, err = reconcileLoadBalancer(ctx, clusterScope, loadBalancerSvc)

        clusterScope.Info("Set OscCluster status to ready")
        clusterScope.SetReady()
        return reconcile.Result{}, nil</span>
}

// reconcileDelete reconcile the deletion of the cluster
func (r *OscClusterReconciler) reconcileDelete(ctx context.Context, clusterScope *scope.ClusterScope) (reconcile.Result, error) <span class="cov0" title="0">{
        clusterScope.Info("Reconcile OscCluster")
        osccluster := clusterScope.OscCluster

        // reconcile deletion of each element of the cluster

        loadBalancerSvc := r.getLoadBalancerSvc(ctx, *clusterScope)
        reconcileDeleteLoadBalancer, err := reconcileDeleteLoadBalancer(ctx, clusterScope, loadBalancerSvc)
        if err != nil </span><span class="cov0" title="0">{
                return reconcileDeleteLoadBalancer, err
        }</span>

        <span class="cov0" title="0">natServiceSvc := r.getNatServiceSvc(ctx, *clusterScope)
        reconcileDeleteNatService, err := reconcileDeleteNatService(ctx, clusterScope, natServiceSvc)
        if err != nil </span><span class="cov0" title="0">{
                return reconcileDeleteNatService, err
        }</span>

        <span class="cov0" title="0">publicIpSvc := r.getPublicIPSvc(ctx, *clusterScope)
        reconcileDeletePublicIp, err := reconcileDeletePublicIP(ctx, clusterScope, publicIpSvc)
        if err != nil </span><span class="cov0" title="0">{
                return reconcileDeletePublicIp, err
        }</span>
        <span class="cov0" title="0">routeTableSvc := r.getRouteTableSvc(ctx, *clusterScope)
        reconcileDeleteRouteTable, err := reconcileDeleteRouteTable(ctx, clusterScope, routeTableSvc)
        if err != nil </span><span class="cov0" title="0">{
                return reconcileDeleteRouteTable, err
        }</span>

        <span class="cov0" title="0">securityGroupSvc := r.getSecurityGroupSvc(ctx, *clusterScope)
        reconcileDeleteSecurityGroup, err := reconcileDeleteSecurityGroup(ctx, clusterScope, securityGroupSvc)
        if err != nil </span><span class="cov0" title="0">{
                return reconcileDeleteSecurityGroup, err
        }</span>

        <span class="cov0" title="0">internetServiceSvc := r.getInternetServiceSvc(ctx, *clusterScope)
        reconcileDeleteInternetService, err := reconcileDeleteInternetService(ctx, clusterScope, internetServiceSvc)
        if err != nil </span><span class="cov0" title="0">{
                return reconcileDeleteInternetService, err
        }</span>

        <span class="cov0" title="0">subnetSvc := r.getSubnetSvc(ctx, *clusterScope)
        reconcileDeleteSubnet, err := reconcileDeleteSubnet(ctx, clusterScope, subnetSvc)
        if err != nil </span><span class="cov0" title="0">{
                return reconcileDeleteSubnet, err
        }</span>

        <span class="cov0" title="0">netSvc := r.getNetSvc(ctx, *clusterScope)
        reconcileDeleteNet, err := reconcileDeleteNet(ctx, clusterScope, netSvc)
        if err != nil </span><span class="cov0" title="0">{
                return reconcileDeleteNet, err
        }</span>
        <span class="cov0" title="0">controllerutil.RemoveFinalizer(osccluster, "oscclusters.infrastructure.cluster.x-k8s.io")
        return reconcile.Result{}, nil</span>
}

// SetupWithManager sets up the controller with the Manager.
func (r *OscClusterReconciler) SetupWithManager(mgr ctrl.Manager) error <span class="cov0" title="0">{
        return ctrl.NewControllerManagedBy(mgr).
                For(&amp;infrastructurev1beta1.OscCluster{}).
                Complete(r)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"
        "fmt"

        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/scope"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/services/net"
        tag "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/tag"
        osc "github.com/outscale/osc-sdk-go/v2"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"
)

// getInternetServiceResourceID return the InternetServiceId from the resourceMap base on resourceName (tag name + cluster object uid)
func getInternetServiceResourceID(resourceName string, clusterScope *scope.ClusterScope) (string, error) <span class="cov8" title="1">{
        internetServiceRef := clusterScope.GetInternetServiceRef()
        if internetServiceId, ok := internetServiceRef.ResourceMap[resourceName]; ok </span><span class="cov8" title="1">{
                return internetServiceId, nil
        }</span> else<span class="cov8" title="1"> {
                return "", fmt.Errorf("%s does not exist", resourceName)
        }</span>
}

// checkInternetServiceFormatParameters check InternetService parameters format
func checkInternetServiceFormatParameters(clusterScope *scope.ClusterScope) (string, error) <span class="cov8" title="1">{
        clusterScope.Info("Check Internet Service parameters")
        internetServiceSpec := clusterScope.GetInternetService()
        internetServiceSpec.SetDefaultValue()
        internetServiceName := internetServiceSpec.Name + "-" + clusterScope.GetUID()
        internetServiceTagName, err := tag.ValidateTagNameValue(internetServiceName)
        if err != nil </span><span class="cov8" title="1">{
                return internetServiceTagName, err
        }</span>
        <span class="cov8" title="1">return "", nil</span>
}

// ReconcileInternetService reconcile the InternetService of the cluster.
func reconcileInternetService(ctx context.Context, clusterScope *scope.ClusterScope, internetServiceSvc net.OscInternetServiceInterface) (reconcile.Result, error) <span class="cov8" title="1">{
        clusterScope.Info("Create InternetGateway")
        internetServiceSpec := clusterScope.GetInternetService()
        internetServiceRef := clusterScope.GetInternetServiceRef()
        internetServiceName := internetServiceSpec.Name + "-" + clusterScope.GetUID()
        var internetService *osc.InternetService
        netSpec := clusterScope.GetNet()
        netSpec.SetDefaultValue()
        netName := netSpec.Name + "-" + clusterScope.GetUID()
        netId, err := getNetResourceID(netName, clusterScope)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov8" title="1">if len(internetServiceRef.ResourceMap) == 0 </span><span class="cov8" title="1">{
                internetServiceRef.ResourceMap = make(map[string]string)
        }</span>
        <span class="cov8" title="1">if internetServiceSpec.ResourceID != "" </span><span class="cov8" title="1">{
                internetServiceRef.ResourceMap[internetServiceName] = internetServiceSpec.ResourceID
                internetServiceId := internetServiceSpec.ResourceID
                clusterScope.Info("Check if the desired internetservice exist", "internetserviceName", internetServiceName)
                clusterScope.Info("### Get internetServiceId ###", "internetservice", internetServiceRef.ResourceMap)
                internetService, err = internetServiceSvc.GetInternetService(internetServiceId)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, err
                }</span>
        }
        <span class="cov8" title="1">if internetService == nil || internetServiceSpec.ResourceID == "" </span><span class="cov8" title="1">{
                clusterScope.Info("Create the desired internetservice", "internetServiceName", internetServiceName)
                internetService, err := internetServiceSvc.CreateInternetService(internetServiceName)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, fmt.Errorf("%w Can not create internetservice for Osccluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
                }</span>
                <span class="cov8" title="1">clusterScope.Info("Link the desired internetservice with a net", "internetServiceName", internetServiceName)
                err = internetServiceSvc.LinkInternetService(*internetService.InternetServiceId, netId)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, fmt.Errorf("%w Can not link internetService with net for Osccluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
                }</span>
                <span class="cov8" title="1">clusterScope.Info("### Get internetService ###", "internetservice", internetService)
                internetServiceRef.ResourceMap[internetServiceName] = internetService.GetInternetServiceId()
                internetServiceSpec.ResourceID = internetService.GetInternetServiceId()</span>

        }
        <span class="cov8" title="1">return reconcile.Result{}, nil</span>
}

// reconcileDeleteInternetService reconcile the destruction of the InternetService of the cluster.
func reconcileDeleteInternetService(ctx context.Context, clusterScope *scope.ClusterScope, internetServiceSvc net.OscInternetServiceInterface) (reconcile.Result, error) <span class="cov8" title="1">{
        osccluster := clusterScope.OscCluster

        clusterScope.Info("Delete internetService")

        internetServiceSpec := clusterScope.GetInternetService()
        internetServiceSpec.SetDefaultValue()

        netSpec := clusterScope.GetNet()
        netSpec.SetDefaultValue()
        netName := netSpec.Name + "-" + clusterScope.GetUID()

        netId, err := getNetResourceID(netName, clusterScope)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>

        <span class="cov8" title="1">internetServiceId := internetServiceSpec.ResourceID
        internetServiceName := internetServiceSpec.Name
        internetService, err := internetServiceSvc.GetInternetService(internetServiceId)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov8" title="1">if internetService == nil </span><span class="cov8" title="1">{
                clusterScope.Info("the desired internetservice does not exist anymore", "internetServiceName", internetServiceName)
                controllerutil.RemoveFinalizer(osccluster, "oscclusters.infrastructure.cluster.x-k8s.io")
                return reconcile.Result{}, nil
        }</span>

        <span class="cov8" title="1">err = internetServiceSvc.UnlinkInternetService(internetServiceId, netId)
        clusterScope.Info("Unlink the desired internetservice", "internetServiceName", internetServiceName)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, fmt.Errorf("%w Can not unlink internetService and net for Osccluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
        }</span>
        <span class="cov8" title="1">err = internetServiceSvc.DeleteInternetService(internetServiceId)
        clusterScope.Info("Delete the desired internetservice", "internetServiceName", internetServiceName)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, fmt.Errorf("%w Can not delete internetService for Osccluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
        }</span>
        <span class="cov8" title="1">return reconcile.Result{}, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"
        "fmt"

        infrastructurev1beta1 "github.com/outscale-dev/cluster-api-provider-outscale.git/api/v1beta1"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/scope"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/services/service"
        clusterv1 "sigs.k8s.io/cluster-api/api/v1beta1"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"
)

// checkLoadBalancerSubneOscAssociateResourceName check that LoadBalancer Subnet dependancies tag name in both resource configuration are the same.
func checkLoadBalancerSubnetOscAssociateResourceName(clusterScope *scope.ClusterScope) error <span class="cov8" title="1">{
        var resourceNameList []string
        clusterScope.Info("check match subnet with loadBalancer")
        loadBalancerSpec := clusterScope.GetLoadBalancer()
        loadBalancerSubnetName := loadBalancerSpec.SubnetName + "-" + clusterScope.GetUID()
        subnetsSpec := clusterScope.GetSubnet()
        for _, subnetSpec := range subnetsSpec </span><span class="cov8" title="1">{
                subnetName := subnetSpec.Name + "-" + clusterScope.GetUID()
                resourceNameList = append(resourceNameList, subnetName)
        }</span>
        <span class="cov8" title="1">checkOscAssociate := Contains(resourceNameList, loadBalancerSubnetName)
        if checkOscAssociate </span><span class="cov8" title="1">{
                return nil
        }</span> else<span class="cov8" title="1"> {
                return fmt.Errorf("%s subnet does not exist in loadBalancer", loadBalancerSubnetName)
        }</span>
}

// checkLoadBalancerFormatParameters check LoadBalancer parameters format (Tag format, cidr format, ..)
func checkLoadBalancerFormatParameters(clusterScope *scope.ClusterScope) (string, error) <span class="cov8" title="1">{
        clusterScope.Info("Check LoadBalancer name parameters")
        loadBalancerSpec := clusterScope.GetLoadBalancer()
        loadBalancerSpec.SetDefaultValue()
        loadBalancerName := loadBalancerSpec.LoadBalancerName

        _, err := infrastructurev1beta1.ValidateLoadBalancerName(loadBalancerName)
        if err != nil </span><span class="cov8" title="1">{
                return loadBalancerName, fmt.Errorf("%s is an invalid loadBalancer name: %w", loadBalancerName, err)
        }</span>

        <span class="cov8" title="1">loadBalancerType := loadBalancerSpec.LoadBalancerType
        _, err = infrastructurev1beta1.ValidateLoadBalancerType(loadBalancerType)
        if err != nil </span><span class="cov8" title="1">{
                return loadBalancerName, fmt.Errorf("%s is an invalid loadBalancer type: %w", loadBalancerType, err)
        }</span>

        <span class="cov8" title="1">loadBalancerBackendPort := loadBalancerSpec.Listener.BackendPort
        _, err = infrastructurev1beta1.ValidatePort(loadBalancerBackendPort)
        if err != nil </span><span class="cov8" title="1">{
                return loadBalancerName, fmt.Errorf("%d is an %w for loadBalancer backend", loadBalancerBackendPort, err)
        }</span>

        <span class="cov8" title="1">loadBalancerBackendProtocol := loadBalancerSpec.Listener.BackendProtocol
        _, err = infrastructurev1beta1.ValidateProtocol(loadBalancerBackendProtocol)
        if err != nil </span><span class="cov8" title="1">{
                return loadBalancerName, fmt.Errorf("%s is an %w for loadBalancer backend", loadBalancerBackendProtocol, err)
        }</span>

        <span class="cov8" title="1">loadBalancerPort := loadBalancerSpec.Listener.LoadBalancerPort
        _, err = infrastructurev1beta1.ValidatePort(loadBalancerPort)
        if err != nil </span><span class="cov8" title="1">{
                return loadBalancerName, fmt.Errorf("%d is an %w for loadBalancer", loadBalancerPort, err)
        }</span>

        <span class="cov8" title="1">loadBalancerProtocol := loadBalancerSpec.Listener.LoadBalancerProtocol
        _, err = infrastructurev1beta1.ValidateProtocol(loadBalancerProtocol)
        if err != nil </span><span class="cov8" title="1">{
                return loadBalancerName, fmt.Errorf("%s is an %w for loadBalancer", loadBalancerProtocol, err)
        }</span>

        <span class="cov8" title="1">loadBalancerCheckInterval := loadBalancerSpec.HealthCheck.CheckInterval
        _, err = infrastructurev1beta1.ValidateInterval(loadBalancerCheckInterval)
        if err != nil </span><span class="cov8" title="1">{
                return loadBalancerName, fmt.Errorf("%d is an %w for loadBalancer", loadBalancerCheckInterval, err)
        }</span>

        <span class="cov8" title="1">loadBalancerHealthyThreshold := loadBalancerSpec.HealthCheck.HealthyThreshold
        _, err = infrastructurev1beta1.ValidateThreshold(loadBalancerHealthyThreshold)
        if err != nil </span><span class="cov8" title="1">{
                return loadBalancerName, fmt.Errorf("%d is an %w for loadBalancer", loadBalancerHealthyThreshold, err)
        }</span>

        <span class="cov8" title="1">loadBalancerHealthCheckPort := loadBalancerSpec.HealthCheck.Port
        _, err = infrastructurev1beta1.ValidatePort(loadBalancerHealthCheckPort)
        if err != nil </span><span class="cov8" title="1">{
                return loadBalancerName, fmt.Errorf("%d is an %w for loadBalancer", loadBalancerHealthCheckPort, err)
        }</span>

        <span class="cov8" title="1">loadBalancerHealthCheckProtocol := loadBalancerSpec.HealthCheck.Protocol
        _, err = infrastructurev1beta1.ValidateProtocol(loadBalancerHealthCheckProtocol)
        if err != nil </span><span class="cov8" title="1">{
                return loadBalancerName, fmt.Errorf("%s is an %w for loadBalancer", loadBalancerHealthCheckProtocol, err)
        }</span>

        <span class="cov8" title="1">loadBalancerTimeout := loadBalancerSpec.HealthCheck.Timeout
        _, err = infrastructurev1beta1.ValidateTimeout(loadBalancerTimeout)
        if err != nil </span><span class="cov8" title="1">{
                return loadBalancerName, fmt.Errorf("%d is an %w for loadBalancer", loadBalancerTimeout, err)
        }</span>

        <span class="cov8" title="1">loadBalancerUnhealthyThreshold := loadBalancerSpec.HealthCheck.UnhealthyThreshold
        _, err = infrastructurev1beta1.ValidateThreshold(loadBalancerUnhealthyThreshold)
        if err != nil </span><span class="cov8" title="1">{
                return loadBalancerName, fmt.Errorf("%d is an %w for loadBalancer", loadBalancerUnhealthyThreshold, err)
        }</span>

        <span class="cov8" title="1">return "", nil</span>
}

// checkLoadBalancerSecurityOscAssociateResourceName check that LoadBalancer SecurityGroup dependancies tag name in both resource configuration are the same.
func checkLoadBalancerSecurityGroupOscAssociateResourceName(clusterScope *scope.ClusterScope) error <span class="cov8" title="1">{
        var resourceNameList []string
        clusterScope.Info("check match securityGroup with loadBalancer")
        loadBalancerSpec := clusterScope.GetLoadBalancer()
        loadBalancerSecurityGroupName := loadBalancerSpec.SecurityGroupName + "-" + clusterScope.GetUID()
        securityGroupsSpec := clusterScope.GetSecurityGroups()
        for _, securityGroupSpec := range securityGroupsSpec </span><span class="cov8" title="1">{
                securityGroupName := securityGroupSpec.Name + "-" + clusterScope.GetUID()
                resourceNameList = append(resourceNameList, securityGroupName)
        }</span>
        <span class="cov8" title="1">checkOscAssociate := Contains(resourceNameList, loadBalancerSecurityGroupName)
        if checkOscAssociate </span><span class="cov8" title="1">{
                return nil
        }</span> else<span class="cov8" title="1"> {
                return fmt.Errorf("%s securityGroup does not exist in loadBalancer", loadBalancerSecurityGroupName)
        }</span>
}

// reconcileLoadBalancer reconciles the loadBalancer of the cluster.
func reconcileLoadBalancer(ctx context.Context, clusterScope *scope.ClusterScope, loadBalancerSvc service.OscLoadBalancerInterface) (reconcile.Result, error) <span class="cov8" title="1">{

        clusterScope.Info("Create Loadbalancer")
        loadBalancerSpec := clusterScope.GetLoadBalancer()
        loadBalancerName := loadBalancerSpec.LoadBalancerName
        clusterScope.Info("Check if the desired loadbalancer exist", "loadBalancerName", loadBalancerName)
        loadbalancer, err := loadBalancerSvc.GetLoadBalancer(loadBalancerSpec)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov8" title="1">subnetName := loadBalancerSpec.SubnetName + "-" + clusterScope.GetUID()
        subnetId, err := getSubnetResourceID(subnetName, clusterScope)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov8" title="1">securityGroupName := loadBalancerSpec.SecurityGroupName + "-" + clusterScope.GetUID()
        securityGroupId, err := getSecurityGroupResourceID(securityGroupName, clusterScope)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov8" title="1">if loadbalancer == nil </span><span class="cov8" title="1">{
                clusterScope.Info("### Get lb subnetId ###", "subnet", subnetId)
                clusterScope.Info("### Get lb  sgId ###", "sg", securityGroupId)
                clusterScope.Info("Create the desired loadBalancer", "loadBalancerName", loadBalancerName)
                _, err := loadBalancerSvc.CreateLoadBalancer(loadBalancerSpec, subnetId, securityGroupId)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, fmt.Errorf("%w Can not create loadBalancer for Osccluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
                }</span>
                <span class="cov8" title="1">clusterScope.Info("Configure the desired loadBalancer", "loadBalancerName", loadBalancerName)
                loadbalancer, err = loadBalancerSvc.ConfigureHealthCheck(loadBalancerSpec)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, fmt.Errorf("%w Can not configure healthcheck for Osccluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
                }</span>
                <span class="cov8" title="1">clusterScope.Info("### Get lb ###", "loadbalancer", loadbalancer)</span>

        }
        <span class="cov8" title="1">controlPlaneEndpoint := *loadbalancer.DnsName
        clusterScope.Info("### Set controlPlaneEndpoint ###", "endpoint", controlPlaneEndpoint)

        controlPlanePort := loadBalancerSpec.Listener.LoadBalancerPort

        clusterScope.SetControlPlaneEndpoint(clusterv1.APIEndpoint{
                Host: controlPlaneEndpoint,
                Port: controlPlanePort,
        })
        return reconcile.Result{}, nil</span>

}

// reconcileDeleteLoadBalancer reconcile the destruction of the LoadBalancer of the cluster.

func reconcileDeleteLoadBalancer(ctx context.Context, clusterScope *scope.ClusterScope, loadBalancerSvc service.OscLoadBalancerInterface) (reconcile.Result, error) <span class="cov8" title="1">{
        osccluster := clusterScope.OscCluster

        clusterScope.Info("Delete LoadBalancer")
        loadBalancerSpec := clusterScope.GetLoadBalancer()
        loadBalancerSpec.SetDefaultValue()
        loadBalancerName := loadBalancerSpec.LoadBalancerName

        loadbalancer, err := loadBalancerSvc.GetLoadBalancer(loadBalancerSpec)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov8" title="1">if loadbalancer == nil </span><span class="cov8" title="1">{
                clusterScope.Info("the desired loadBalancer does not exist anymore", "loadBalancerName", loadBalancerName)
                controllerutil.RemoveFinalizer(osccluster, "oscclusters.infrastructure.cluster.x-k8s.io")
                return reconcile.Result{}, nil
        }</span>
        <span class="cov8" title="1">err = loadBalancerSvc.CheckLoadBalancerDeregisterVM(5, 120, loadBalancerSpec)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, fmt.Errorf("%w VmBackend is not deregister in loadBalancer %s for OscCluster %s/%s", err, loadBalancerSpec.LoadBalancerName, clusterScope.GetNamespace(), clusterScope.GetName())
        }</span>

        <span class="cov8" title="1">err = loadBalancerSvc.DeleteLoadBalancer(loadBalancerSpec)
        if err != nil </span><span class="cov8" title="1">{
                clusterScope.Info("Delete the desired loadBalancer", "loadBalancerName", loadBalancerName)
                return reconcile.Result{}, fmt.Errorf("%w Can not delete loadBalancer for Osccluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
        }</span>
        <span class="cov8" title="1">return reconcile.Result{}, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"
        "fmt"

        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/scope"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/services/net"
        tag "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/tag"
        osc "github.com/outscale/osc-sdk-go/v2"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"
)

// GetNatResourceID return the NatId from the resourceMap base on NatName (tag name + cluster object uid)
func getNatResourceID(resourceName string, clusterScope *scope.ClusterScope) (string, error) <span class="cov8" title="1">{
        natServiceRef := clusterScope.GetNatServiceRef()
        if natServiceId, ok := natServiceRef.ResourceMap[resourceName]; ok </span><span class="cov8" title="1">{
                return natServiceId, nil
        }</span> else<span class="cov8" title="1"> {
                return "", fmt.Errorf("%s does not exist", resourceName)
        }</span>
}

func checkNatFormatParameters(clusterScope *scope.ClusterScope) (string, error) <span class="cov8" title="1">{
        clusterScope.Info("Check Nat name parameters")
        natServiceSpec := clusterScope.GetNatService()
        natServiceSpec.SetDefaultValue()
        natName := natServiceSpec.Name + "-" + clusterScope.GetUID()
        natSubnetName := natServiceSpec.SubnetName + "-" + clusterScope.GetUID()
        natPublicIPName := natServiceSpec.PublicIPName + "-" + clusterScope.GetUID()
        natTagName, err := tag.ValidateTagNameValue(natName)
        if err != nil </span><span class="cov8" title="1">{
                return natTagName, err
        }</span>
        <span class="cov8" title="1">natSubnetTagName, err := tag.ValidateTagNameValue(natSubnetName)
        if err != nil </span><span class="cov8" title="1">{
                return natSubnetTagName, err
        }</span>
        <span class="cov8" title="1">natPublicIpTagName, err := tag.ValidateTagNameValue(natPublicIPName)
        if err != nil </span><span class="cov8" title="1">{
                return natPublicIpTagName, err
        }</span>
        <span class="cov8" title="1">return "", nil</span>
}

// checkNatSubnetOscAssociateResourceName check that Nat Subnet dependancies tag name in both resource configuration are the same.
func checkNatSubnetOscAssociateResourceName(clusterScope *scope.ClusterScope) error <span class="cov8" title="1">{
        var resourceNameList []string
        clusterScope.Info("check match subnet with nat service")
        natServiceSpec := clusterScope.GetNatService()
        natServiceSpec.SetDefaultValue()
        natSubnetName := natServiceSpec.SubnetName + "-" + clusterScope.GetUID()
        subnetsSpec := clusterScope.GetSubnet()
        for _, subnetSpec := range subnetsSpec </span><span class="cov8" title="1">{
                subnetName := subnetSpec.Name + "-" + clusterScope.GetUID()
                resourceNameList = append(resourceNameList, subnetName)
        }</span>
        <span class="cov8" title="1">checkOscAssociate := Contains(resourceNameList, natSubnetName)
        if checkOscAssociate </span><span class="cov8" title="1">{
                return nil
        }</span> else<span class="cov8" title="1"> {
                return fmt.Errorf("%s subnet does not exist in natService", natSubnetName)
        }</span>
}

// reconcileNatService reconcile the NatService of the cluster.
func reconcileNatService(ctx context.Context, clusterScope *scope.ClusterScope, natServiceSvc net.OscNatServiceInterface) (reconcile.Result, error) <span class="cov8" title="1">{

        clusterScope.Info("Create NatService")
        natServiceSpec := clusterScope.GetNatService()

        natServiceRef := clusterScope.GetNatServiceRef()
        natServiceName := natServiceSpec.Name + "-" + clusterScope.GetUID()
        var natService *osc.NatService
        publicIpName := natServiceSpec.PublicIPName + "-" + clusterScope.GetUID()
        publicIpId, err := getPublicIPResourceID(publicIpName, clusterScope)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>

        <span class="cov8" title="1">subnetName := natServiceSpec.SubnetName + "-" + clusterScope.GetUID()

        subnetId, err := getSubnetResourceID(subnetName, clusterScope)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov8" title="1">if len(natServiceRef.ResourceMap) == 0 </span><span class="cov8" title="1">{
                natServiceRef.ResourceMap = make(map[string]string)
        }</span>
        <span class="cov8" title="1">if natServiceSpec.ResourceID != "" </span><span class="cov8" title="1">{
                natServiceRef.ResourceMap[natServiceName] = natServiceSpec.ResourceID
                natServiceId := natServiceSpec.ResourceID
                clusterScope.Info("Check if the desired natService exist")
                clusterScope.Info("### Get natService Id ###", "natService", natServiceRef.ResourceMap)
                natService, err = natServiceSvc.GetNatService(natServiceId)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, err
                }</span>
        }

        <span class="cov8" title="1">if natService == nil || natServiceSpec.ResourceID == "" </span><span class="cov8" title="1">{
                clusterScope.Info("Create the desired natService", "natServiceName", natServiceName)
                natService, err := natServiceSvc.CreateNatService(publicIpId, subnetId, natServiceName)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, fmt.Errorf("%w Can not create natService for Osccluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
                }</span>
                <span class="cov8" title="1">clusterScope.Info("### Get natService ###", "natService", natService)
                natServiceRef.ResourceMap[natServiceName] = natService.GetNatServiceId()
                natServiceSpec.ResourceID = natService.GetNatServiceId()</span>
        }
        <span class="cov8" title="1">return reconcile.Result{}, nil</span>
}

// reconcileDeleteNatService reconcile the destruction of the NatService of the cluster.
func reconcileDeleteNatService(ctx context.Context, clusterScope *scope.ClusterScope, natServiceSvc net.OscNatServiceInterface) (reconcile.Result, error) <span class="cov8" title="1">{
        osccluster := clusterScope.OscCluster

        clusterScope.Info("Delete natService")
        natServiceSpec := clusterScope.GetNatService()
        natServiceSpec.SetDefaultValue()
        natServiceName := natServiceSpec.Name + "-" + clusterScope.GetUID()

        natServiceId := natServiceSpec.ResourceID
        natService, err := natServiceSvc.GetNatService(natServiceId)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov8" title="1">if natService == nil </span><span class="cov8" title="1">{
                clusterScope.Info("the desired natService does not exist anymore", "natServiceName", natServiceName)
                controllerutil.RemoveFinalizer(osccluster, "oscclusters.infrastructure.cluster.x-k8s.io")
                return reconcile.Result{}, nil
        }</span>
        <span class="cov8" title="1">err = natServiceSvc.DeleteNatService(natServiceId)
        if err != nil </span><span class="cov8" title="1">{
                clusterScope.Info("Delete the desired natService", "natServiceName", natServiceName)
                return reconcile.Result{}, fmt.Errorf("%w Can not delete natService for Osccluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
        }</span>
        <span class="cov8" title="1">return reconcile.Result{}, err</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"
        "fmt"

        infrastructurev1beta1 "github.com/outscale-dev/cluster-api-provider-outscale.git/api/v1beta1"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/scope"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/services/net"
        tag "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/tag"
        osc "github.com/outscale/osc-sdk-go/v2"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"
)

// getNetResourceID return the netId from the resourceMap base on resourceName (tag name + cluster object uid)
func getNetResourceID(resourceName string, clusterScope *scope.ClusterScope) (string, error) <span class="cov8" title="1">{
        netRef := clusterScope.GetNetRef()
        if netId, ok := netRef.ResourceMap[resourceName]; ok </span><span class="cov8" title="1">{
                return netId, nil
        }</span> else<span class="cov8" title="1"> {
                return "", fmt.Errorf("%s does not exist", resourceName)
        }</span>
}

// checkNetFormatParameters check net parameters format (Tag format, cidr format, ..)
func checkNetFormatParameters(clusterScope *scope.ClusterScope) (string, error) <span class="cov8" title="1">{
        clusterScope.Info("Check Net name parameters ")
        netSpec := clusterScope.GetNet()
        netSpec.SetDefaultValue()
        netName := netSpec.Name + "-" + clusterScope.GetUID()
        netTagName, err := tag.ValidateTagNameValue(netName)
        if err != nil </span><span class="cov8" title="1">{
                return netTagName, err
        }</span>
        <span class="cov8" title="1">clusterScope.Info("Check Net.IPRange parameters")
        netIPRange := netSpec.IPRange
        _, err = infrastructurev1beta1.ValidateCidr(netIPRange)
        if err != nil </span><span class="cov8" title="1">{
                return netTagName, err
        }</span>
        <span class="cov8" title="1">return "", nil</span>
}

// reconcileNet reconcile the Net of the cluster.
func reconcileNet(ctx context.Context, clusterScope *scope.ClusterScope, netSvc net.OscNetInterface) (reconcile.Result, error) <span class="cov8" title="1">{
        clusterScope.Info("Create Net")
        netSpec := clusterScope.GetNet()
        netSpec.SetDefaultValue()
        netRef := clusterScope.GetNetRef()
        netName := netSpec.Name + "-" + clusterScope.GetUID()
        var net *osc.Net
        var err error
        if len(netRef.ResourceMap) == 0 </span><span class="cov8" title="1">{
                netRef.ResourceMap = make(map[string]string)
        }</span>
        <span class="cov8" title="1">if netSpec.ResourceID != "" </span><span class="cov8" title="1">{
                netRef.ResourceMap[netName] = netSpec.ResourceID
                netId := netSpec.ResourceID
                clusterScope.Info("Check if the desired net exist", "netName", netName)
                clusterScope.Info("### Get netId ###", "net", netRef.ResourceMap)
                net, err = netSvc.GetNet(netId)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, err
                }</span>

        }
        <span class="cov8" title="1">if net == nil || netSpec.ResourceID == "" </span><span class="cov8" title="1">{
                clusterScope.Info("Create the desired net", "netName", netName)
                net, err := netSvc.CreateNet(netSpec, netName)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, fmt.Errorf("%w Can not create net for Osccluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
                }</span>
                <span class="cov8" title="1">clusterScope.Info("### Get net ###", "net", net)
                netRef.ResourceMap[netName] = net.GetNetId()
                netSpec.ResourceID = *net.NetId
                netRef.ResourceMap[netName] = net.GetNetId()
                netSpec.ResourceID = net.GetNetId()</span>
        }
        <span class="cov8" title="1">return reconcile.Result{}, nil</span>
}

// reconcileDeleteNet reconcile the destruction of the Net of the cluster.
func reconcileDeleteNet(ctx context.Context, clusterScope *scope.ClusterScope, netSvc net.OscNetInterface) (reconcile.Result, error) <span class="cov8" title="1">{
        osccluster := clusterScope.OscCluster

        netSpec := clusterScope.GetNet()
        netSpec.SetDefaultValue()
        netId := netSpec.ResourceID
        netName := netSpec.Name + "-" + clusterScope.GetUID()

        clusterScope.Info("Delete net")
        net, err := netSvc.GetNet(netId)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov8" title="1">if net == nil </span><span class="cov8" title="1">{
                clusterScope.Info("The desired net does not exist anymore", "netName", netName)
                controllerutil.RemoveFinalizer(osccluster, "oscclusters.infrastructure.cluster.x-k8s.io")
                return reconcile.Result{}, nil
        }</span>
        <span class="cov8" title="1">err = netSvc.DeleteNet(netId)
        if err != nil </span><span class="cov8" title="1">{
                clusterScope.Info("Delete the desired net", "netName", netName)
                return reconcile.Result{}, fmt.Errorf("%w Can not delete net for Osccluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
        }</span>
        <span class="cov8" title="1">return reconcile.Result{}, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"
        "fmt"

        infrastructurev1beta1 "github.com/outscale-dev/cluster-api-provider-outscale.git/api/v1beta1"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/scope"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/services/security"
        tag "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/tag"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"
)

// getPublicIPResourceID return the resourceId from the resourceMap base on PublicIPName  (tag name + cluster object uid)
func getPublicIPResourceID(resourceName string, clusterScope *scope.ClusterScope) (string, error) <span class="cov8" title="1">{
        publicIpRef := clusterScope.GetPublicIPRef()
        if publicIpId, ok := publicIpRef.ResourceMap[resourceName]; ok </span><span class="cov8" title="1">{
                return publicIpId, nil
        }</span> else<span class="cov8" title="1"> {
                return "", fmt.Errorf("%s does not exist", resourceName)
        }</span>
}

// getLinkPublicIPResourceID return linkPublicIP
func getLinkPublicIPResourceID(resourceName string, machineScope *scope.MachineScope) (string, error) <span class="cov0" title="0">{
        linkPublicIpRef := machineScope.GetLinkPublicIPRef()
        if linkPublicIpId, ok := linkPublicIpRef.ResourceMap[resourceName]; ok </span><span class="cov0" title="0">{
                return linkPublicIpId, nil
        }</span> else<span class="cov0" title="0"> {
                return "", fmt.Errorf("%s does not exist", resourceName)
        }</span>
}

// checkPublicIPFormatParameters check PublicIp parameters format (Tag format, cidr format, ..)
func checkPublicIPFormatParameters(clusterScope *scope.ClusterScope) (string, error) <span class="cov8" title="1">{
        clusterScope.Info("Check Public Ip parameters")
        var publicIpsSpec []*infrastructurev1beta1.OscPublicIP
        networkSpec := clusterScope.GetNetwork()
        if networkSpec.PublicIPS == nil </span><span class="cov8" title="1">{
                networkSpec.SetPublicIPDefaultValue()
                publicIpsSpec = networkSpec.PublicIPS
        }</span> else<span class="cov8" title="1"> {
                publicIpsSpec = clusterScope.GetPublicIP()
        }</span>
        <span class="cov8" title="1">for _, publicIpSpec := range publicIpsSpec </span><span class="cov8" title="1">{
                publicIpName := publicIpSpec.Name + "-" + clusterScope.GetUID()
                publicIpTagName, err := tag.ValidateTagNameValue(publicIpName)
                if err != nil </span><span class="cov8" title="1">{
                        return publicIpTagName, err
                }</span>
        }
        <span class="cov8" title="1">return "", nil</span>
}

// checkPublicIPOscAssociateResourceName check that PublicIp dependancies tag name in both resource configuration are the same.
func checkPublicIPOscAssociateResourceName(clusterScope *scope.ClusterScope) error <span class="cov8" title="1">{
        clusterScope.Info("check match public ip with nat service")
        var resourceNameList []string
        natServiceSpec := clusterScope.GetNatService()
        natServiceSpec.SetDefaultValue()
        natPublicIPName := natServiceSpec.PublicIPName + "-" + clusterScope.GetUID()
        var publicIpsSpec []*infrastructurev1beta1.OscPublicIP
        networkSpec := clusterScope.GetNetwork()
        publicIpsSpec = networkSpec.PublicIPS
        for _, publicIpSpec := range publicIpsSpec </span><span class="cov8" title="1">{
                publicIpName := publicIpSpec.Name + "-" + clusterScope.GetUID()
                resourceNameList = append(resourceNameList, publicIpName)
        }</span>
        <span class="cov8" title="1">checkOscAssociate := Contains(resourceNameList, natPublicIPName)
        if checkOscAssociate </span><span class="cov8" title="1">{
                return nil
        }</span> else<span class="cov8" title="1"> {
                return fmt.Errorf("publicIp %s does not exist in natService ", natPublicIPName)
        }</span>
}

// checkPublicIpOscDuplicateName check that there are not the same name for PublicIp resource.
func checkPublicIPOscDuplicateName(clusterScope *scope.ClusterScope) error <span class="cov8" title="1">{
        clusterScope.Info("Check unique name publicIp")
        var resourceNameList []string
        publicIpsSpec := clusterScope.GetPublicIP()
        for _, publicIpSpec := range publicIpsSpec </span><span class="cov8" title="1">{
                resourceNameList = append(resourceNameList, publicIpSpec.Name)
        }</span>
        <span class="cov8" title="1">duplicateResourceErr := alertDuplicate(resourceNameList)
        if duplicateResourceErr != nil </span><span class="cov8" title="1">{
                return duplicateResourceErr
        }</span> else<span class="cov8" title="1"> {
                return nil
        }</span>
}

// reconcilePublicIP reconcile the PublicIp of the cluster.
func reconcilePublicIP(ctx context.Context, clusterScope *scope.ClusterScope, publicIpSvc security.OscPublicIPInterface) (reconcile.Result, error) <span class="cov8" title="1">{

        clusterScope.Info("Create PublicIp")
        var publicIpsSpec []*infrastructurev1beta1.OscPublicIP
        publicIpsSpec = clusterScope.GetPublicIP()
        var publicIpId string
        publicIpRef := clusterScope.GetPublicIPRef()
        var publicIpIds []string
        for _, publicIpSpec := range publicIpsSpec </span><span class="cov8" title="1">{
                publicIpId = publicIpSpec.ResourceID
                publicIpIds = append(publicIpIds, publicIpId)
        }</span>
        <span class="cov8" title="1">clusterScope.Info("Check if the desired publicip exist")
        validPublicIpIds, err := publicIpSvc.ValidatePublicIPIds(publicIpIds)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov8" title="1">clusterScope.Info("### Check Id  ###", "publicip", publicIpIds)
        for _, publicIpSpec := range publicIpsSpec </span><span class="cov8" title="1">{
                publicIpName := publicIpSpec.Name + "-" + clusterScope.GetUID()
                clusterScope.Info("### Get publicIp Id ###", "publicip", publicIpRef.ResourceMap)
                if len(publicIpRef.ResourceMap) == 0 </span><span class="cov8" title="1">{
                        publicIpRef.ResourceMap = make(map[string]string)
                }</span>
                <span class="cov8" title="1">if publicIpSpec.ResourceID != "" </span><span class="cov8" title="1">{
                        publicIpRef.ResourceMap[publicIpName] = publicIpSpec.ResourceID
                }</span>
                <span class="cov8" title="1">_, resourceMapExist := publicIpRef.ResourceMap[publicIpName]
                if resourceMapExist </span><span class="cov8" title="1">{
                        publicIpSpec.ResourceID = publicIpRef.ResourceMap[publicIpName]
                }</span>

                <span class="cov8" title="1">publicIpId := publicIpRef.ResourceMap[publicIpName]
                if !Contains(validPublicIpIds, publicIpId) </span><span class="cov8" title="1">{
                        publicIp, err := publicIpSvc.CreatePublicIP(publicIpName)
                        if err != nil </span><span class="cov8" title="1">{
                                return reconcile.Result{}, fmt.Errorf("%w Can not create publicIp for Osccluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
                        }</span>
                        <span class="cov8" title="1">clusterScope.Info("### Get publicIp  ###", "publicip", publicIp)
                        publicIpRef.ResourceMap[publicIpName] = publicIp.GetPublicIpId()
                        publicIpSpec.ResourceID = publicIp.GetPublicIpId()</span>
                }
        }
        <span class="cov8" title="1">return reconcile.Result{}, nil</span>
}

// reconcileDeletePublicIP reconcile the destruction of the PublicIp of the cluster.
func reconcileDeletePublicIP(ctx context.Context, clusterScope *scope.ClusterScope, publicIpSvc security.OscPublicIPInterface) (reconcile.Result, error) <span class="cov8" title="1">{
        osccluster := clusterScope.OscCluster

        clusterScope.Info("Delete PublicIp")
        var publicIpsSpec []*infrastructurev1beta1.OscPublicIP
        networkSpec := clusterScope.GetNetwork()
        if networkSpec.PublicIPS == nil </span><span class="cov8" title="1">{
                networkSpec.SetPublicIPDefaultValue()
                publicIpsSpec = networkSpec.PublicIPS
        }</span> else<span class="cov8" title="1"> {
                publicIpsSpec = clusterScope.GetPublicIP()
        }</span>
        <span class="cov8" title="1">var publicIpIds []string
        var publicIpId string
        for _, publicIpSpec := range publicIpsSpec </span><span class="cov8" title="1">{
                publicIpId = publicIpSpec.ResourceID
                publicIpIds = append(publicIpIds, publicIpId)
        }</span>
        <span class="cov8" title="1">validPublicIpIds, err := publicIpSvc.ValidatePublicIPIds(publicIpIds)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov8" title="1">clusterScope.Info("### Check Id  ###", "publicip", publicIpIds)
        for _, publicIpSpec := range publicIpsSpec </span><span class="cov8" title="1">{
                publicIpId := publicIpSpec.ResourceID
                clusterScope.Info("### check PublicIp Id ###", "publicipid", publicIpId)
                publicIpName := publicIpSpec.Name + "-" + clusterScope.GetUID()
                clusterScope.Info("### Check validPublicIpIds###", "validPublicIpIds", validPublicIpIds)
                if !Contains(validPublicIpIds, publicIpId) </span><span class="cov8" title="1">{
                        controllerutil.RemoveFinalizer(osccluster, "oscclusters.infrastructure.cluster.x-k8s.io")
                        return reconcile.Result{}, nil
                }</span>
                <span class="cov8" title="1">err = publicIpSvc.CheckPublicIPUnlink(5, 120, publicIpId)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, fmt.Errorf("%w Can not delete publicIp %s for Osccluster %s/%s", err, publicIpId, clusterScope.GetNamespace(), clusterScope.GetName())
                }</span>

                <span class="cov8" title="1">clusterScope.Info("Remove publicip")
                clusterScope.Info("Delete the desired publicip", "publicIpName", publicIpName)
                err = publicIpSvc.DeletePublicIP(publicIpId)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, fmt.Errorf("%w Can not delete publicIp for Osccluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
                }</span>

        }
        <span class="cov8" title="1">return reconcile.Result{}, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"
        "fmt"

        infrastructurev1beta1 "github.com/outscale-dev/cluster-api-provider-outscale.git/api/v1beta1"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/scope"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/services/security"
        tag "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/tag"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"
)

// getRouteTableResourceID return the RouteTableId from the resourceMap base on RouteTableName (tag name + cluster object uid)
func getRouteTableResourceID(resourceName string, clusterScope *scope.ClusterScope) (string, error) <span class="cov8" title="1">{
        routeTableRef := clusterScope.GetRouteTablesRef()
        if routeTableId, ok := routeTableRef.ResourceMap[resourceName]; ok </span><span class="cov8" title="1">{
                return routeTableId, nil
        }</span> else<span class="cov8" title="1"> {
                return "", fmt.Errorf("%s does not exist", resourceName)
        }</span>
}

// getRouteResourceID return the resourceId from the resourceMap base on routeName (tag name + cluster object uid)
func getRouteResourceID(resourceName string, clusterScope *scope.ClusterScope) (string, error) <span class="cov8" title="1">{
        routeRef := clusterScope.GetRouteRef()
        if routeId, ok := routeRef.ResourceMap[resourceName]; ok </span><span class="cov8" title="1">{
                return routeId, nil
        }</span> else<span class="cov8" title="1"> {
                return "", fmt.Errorf("%s does not exist", resourceName)
        }</span>
}

// checkRouteFormatParameters check Route parameters format (Tag format, cidr format, ..)
func checkRouteTableFormatParameters(clusterScope *scope.ClusterScope) (string, error) <span class="cov8" title="1">{
        clusterScope.Info("Check Route table parameters")
        var routeTablesSpec []*infrastructurev1beta1.OscRouteTable
        networkSpec := clusterScope.GetNetwork()
        if networkSpec.RouteTables == nil </span><span class="cov8" title="1">{
                networkSpec.SetRouteTableDefaultValue()
                routeTablesSpec = networkSpec.RouteTables
        }</span> else<span class="cov8" title="1"> {
                routeTablesSpec = clusterScope.GetRouteTables()
        }</span>
        <span class="cov8" title="1">for _, routeTableSpec := range routeTablesSpec </span><span class="cov8" title="1">{
                routeTableName := routeTableSpec.Name + "-" + clusterScope.GetUID()
                routeTableTagName, err := tag.ValidateTagNameValue(routeTableName)
                if err != nil </span><span class="cov8" title="1">{
                        return routeTableTagName, err
                }</span>
        }
        <span class="cov8" title="1">return "", nil</span>
}

// checkRouteFormatParameters check Route parameters format (Tag format, cidr format, ..)
func checkRouteFormatParameters(clusterScope *scope.ClusterScope) (string, error) <span class="cov8" title="1">{
        clusterScope.Info("Check Route parameters")
        var routeTablesSpec []*infrastructurev1beta1.OscRouteTable
        routeTablesSpec = clusterScope.GetRouteTables()
        for _, routeTableSpec := range routeTablesSpec </span><span class="cov8" title="1">{
                routesSpec := clusterScope.GetRoute(routeTableSpec.Name)
                for _, routeSpec := range *routesSpec </span><span class="cov8" title="1">{
                        routeName := routeSpec.Name + "-" + clusterScope.GetUID()
                        routeTagName, err := tag.ValidateTagNameValue(routeName)
                        if err != nil </span><span class="cov8" title="1">{
                                return routeTagName, err
                        }</span>
                        <span class="cov8" title="1">clusterScope.Info("Check route destination IpRange parameters")
                        destinationIpRange := routeSpec.Destination
                        _, err = infrastructurev1beta1.ValidateCidr(destinationIpRange)
                        if err != nil </span><span class="cov8" title="1">{
                                return routeTagName, err
                        }</span>
                }
        }
        <span class="cov8" title="1">return "", nil</span>
}

// checkRouteTableSubnetOscAssociateResourceName check that RouteTable Subnet dependancies tag name in both resource configuration are the same.
func checkRouteTableSubnetOscAssociateResourceName(clusterScope *scope.ClusterScope) error <span class="cov8" title="1">{
        var resourceNameList []string
        clusterScope.Info("check match subnet with route table service")
        routeTablesSpec := clusterScope.GetRouteTables()
        resourceNameList = resourceNameList[:0]
        subnetsSpec := clusterScope.GetSubnet()
        for _, subnetSpec := range subnetsSpec </span><span class="cov8" title="1">{
                subnetName := subnetSpec.Name + "-" + clusterScope.GetUID()
                resourceNameList = append(resourceNameList, subnetName)
        }</span>
        <span class="cov8" title="1">for _, routeTableSpec := range routeTablesSpec </span><span class="cov8" title="1">{
                routeTableSubnetName := routeTableSpec.SubnetName + "-" + clusterScope.GetUID()
                checkOscAssociate := Contains(resourceNameList, routeTableSubnetName)
                if checkOscAssociate </span><span class="cov8" title="1">{
                        return nil
                }</span> else<span class="cov8" title="1"> {
                        return fmt.Errorf("%s subnet dooes not exist in routeTable", routeTableSubnetName)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// checkRouteTableOscDuplicateName check that there are not the same name for RouteTable.
func checkRouteTableOscDuplicateName(clusterScope *scope.ClusterScope) error <span class="cov8" title="1">{
        var resourceNameList []string
        clusterScope.Info("check unique routetable")
        routeTablesSpec := clusterScope.GetRouteTables()
        for _, routeTableSpec := range routeTablesSpec </span><span class="cov8" title="1">{
                resourceNameList = append(resourceNameList, routeTableSpec.Name)
        }</span>
        <span class="cov8" title="1">duplicateResourceErr := alertDuplicate(resourceNameList)
        if duplicateResourceErr != nil </span><span class="cov8" title="1">{
                return duplicateResourceErr
        }</span> else<span class="cov8" title="1"> {
                return nil
        }</span>
}

// checkRouteOscDuplicateName check that there are not the same name for route.
func checkRouteOscDuplicateName(clusterScope *scope.ClusterScope) error <span class="cov8" title="1">{
        var resourceNameList []string
        clusterScope.Info("check unique route")
        routeTablesSpec := clusterScope.GetRouteTables()
        for _, routeTableSpec := range routeTablesSpec </span><span class="cov8" title="1">{
                routesSpec := clusterScope.GetRoute(routeTableSpec.Name)
                for _, routeSpec := range *routesSpec </span><span class="cov8" title="1">{
                        resourceNameList = append(resourceNameList, routeSpec.Name)
                }</span>
                <span class="cov8" title="1">duplicateResourceErr := alertDuplicate(resourceNameList)
                if duplicateResourceErr != nil </span><span class="cov8" title="1">{
                        return duplicateResourceErr
                }</span> else<span class="cov8" title="1"> {
                        return nil
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// reconcileRoute reconcile the RouteTable and the Route of the cluster.
func reconcileRoute(ctx context.Context, clusterScope *scope.ClusterScope, routeSpec infrastructurev1beta1.OscRoute, routeTableName string, routeTableSvc security.OscRouteTableInterface) (reconcile.Result, error) <span class="cov8" title="1">{
        routeRef := clusterScope.GetRouteRef()
        routeTablesRef := clusterScope.GetRouteTablesRef()

        resourceName := routeSpec.TargetName + "-" + clusterScope.GetUID()
        resourceType := routeSpec.TargetType
        routeName := routeSpec.Name + "-" + clusterScope.GetUID()
        if len(routeRef.ResourceMap) == 0 </span><span class="cov8" title="1">{
                routeRef.ResourceMap = make(map[string]string)
        }</span>
        <span class="cov8" title="1">var resourceId string
        var err error
        if resourceType == "gateway" </span><span class="cov8" title="1">{
                resourceId, err = getInternetServiceResourceID(resourceName, clusterScope)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, err
                }</span>
        } else<span class="cov8" title="1"> {
                resourceId, err = getNatResourceID(resourceName, clusterScope)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, err
                }</span>
        }
        <span class="cov8" title="1">destinationIpRange := routeSpec.Destination
        associateRouteTableId := routeTablesRef.ResourceMap[routeTableName]
        clusterScope.Info("check if the desired route exist", "routename", routeName)
        routeTableFromRoute, err := routeTableSvc.GetRouteTableFromRoute(associateRouteTableId, resourceId, resourceType)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov8" title="1">if routeTableFromRoute == nil </span><span class="cov8" title="1">{
                clusterScope.Info("### Create Route ###", "Route", resourceId)
                clusterScope.Info("Create the desired route", "routeName", routeName)
                routeTableFromRoute, err = routeTableSvc.CreateRoute(destinationIpRange, routeTablesRef.ResourceMap[routeTableName], resourceId, resourceType)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, fmt.Errorf("%w Can not create route for Osccluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
                }</span>
        }

        <span class="cov8" title="1">routeRef.ResourceMap[routeName] = routeTableFromRoute.GetRouteTableId()
        return reconcile.Result{}, nil</span>

}

// reconcileRoute reconcile the RouteTable and the Route of the cluster.
func reconcileDeleteRoute(ctx context.Context, clusterScope *scope.ClusterScope, routeSpec infrastructurev1beta1.OscRoute, routeTableName string, routeTableSvc security.OscRouteTableInterface) (reconcile.Result, error) <span class="cov8" title="1">{
        osccluster := clusterScope.OscCluster

        routeTablesRef := clusterScope.GetRouteTablesRef()

        resourceName := routeSpec.TargetName + "-" + clusterScope.GetUID()
        resourceType := routeSpec.TargetType
        routeName := routeSpec.Name + "-" + clusterScope.GetUID()
        var resourceId string
        var err error
        if resourceType == "gateway" </span><span class="cov8" title="1">{
                resourceId, err = getInternetServiceResourceID(resourceName, clusterScope)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, err
                }</span>
        } else<span class="cov8" title="1"> {
                resourceId, err = getNatResourceID(resourceName, clusterScope)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, err
                }</span>
        }
        <span class="cov8" title="1">routeTableId, err := getRouteResourceID(routeName, clusterScope)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov8" title="1">destinationIpRange := routeSpec.Destination
        associateRouteTableId := routeTablesRef.ResourceMap[routeTableName]

        clusterScope.Info("Check if the desired route still exist", "routeName", routeName)
        routeTableFromRoute, err := routeTableSvc.GetRouteTableFromRoute(associateRouteTableId, resourceId, resourceType)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov8" title="1">if routeTableFromRoute == nil </span><span class="cov8" title="1">{
                clusterScope.Info("the desired route does not exist anymore", "routeName", routeName)
                controllerutil.RemoveFinalizer(osccluster, "oscclusters.infrastructure.cluster.x-k8s.io")
                return reconcile.Result{}, nil
        }</span>
        <span class="cov8" title="1">clusterScope.Info("Delete Route")
        clusterScope.Info("### delete destinationIpRange###", "routeTable", destinationIpRange)

        clusterScope.Info("Delete the desired route", "routeName", routeName)
        err = routeTableSvc.DeleteRoute(destinationIpRange, routeTableId)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, fmt.Errorf("%w Can not delete route for Osccluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
        }</span>
        <span class="cov8" title="1">return reconcile.Result{}, nil</span>

}

// reconcileRouteTable reconcile the RouteTable and the Route of the cluster.
func reconcileRouteTable(ctx context.Context, clusterScope *scope.ClusterScope, routeTableSvc security.OscRouteTableInterface) (reconcile.Result, error) <span class="cov8" title="1">{

        clusterScope.Info("Create RouteTable")
        routeTablesSpec := clusterScope.GetRouteTables()
        routeTablesRef := clusterScope.GetRouteTablesRef()
        linkRouteTablesRef := clusterScope.GetLinkRouteTablesRef()

        netSpec := clusterScope.GetNet()
        netSpec.SetDefaultValue()
        netName := netSpec.Name + "-" + clusterScope.GetUID()
        netId, err := getNetResourceID(netName, clusterScope)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>

        <span class="cov8" title="1">clusterScope.Info("Get list of all desired routetable in net", "netId", netId)
        routeTableIds, err := routeTableSvc.GetRouteTableIdsFromNetIds(netId)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov8" title="1">for _, routeTableSpec := range routeTablesSpec </span><span class="cov8" title="1">{
                routeTableName := routeTableSpec.Name + "-" + clusterScope.GetUID()
                clusterScope.Info("Check if the desired routeTable existin net", "routeTableName", routeTableName)
                clusterScope.Info("### Get routeTable Id ###", "routeTable", routeTablesRef.ResourceMap)
                subnetName := routeTableSpec.SubnetName + "-" + clusterScope.GetUID()
                subnetId, err := getSubnetResourceID(subnetName, clusterScope)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, err
                }</span>

                <span class="cov8" title="1">if len(routeTablesRef.ResourceMap) == 0 </span><span class="cov8" title="1">{
                        routeTablesRef.ResourceMap = make(map[string]string)
                }</span>
                <span class="cov8" title="1">if len(linkRouteTablesRef.ResourceMap) == 0 </span><span class="cov8" title="1">{
                        linkRouteTablesRef.ResourceMap = make(map[string]string)
                }</span>
                <span class="cov8" title="1">if routeTableSpec.ResourceID != "" </span><span class="cov8" title="1">{
                        routeTablesRef.ResourceMap[routeTableName] = routeTableSpec.ResourceID
                }</span>
                <span class="cov8" title="1">_, resourceMapExist := routeTablesRef.ResourceMap[routeTableName]
                if resourceMapExist </span><span class="cov8" title="1">{
                        routeTableSpec.ResourceID = routeTablesRef.ResourceMap[routeTableName]
                }</span>

                <span class="cov8" title="1">routeTableId := routeTablesRef.ResourceMap[routeTableName]
                var natRouteTable bool = false

                if !Contains(routeTableIds, routeTableId) </span><span class="cov8" title="1">{
                        clusterScope.Info("check Nat RouteTable")
                        routesSpec := clusterScope.GetRoute(routeTableSpec.Name)

                        for _, routeSpec := range *routesSpec </span><span class="cov8" title="1">{
                                resourceType := routeSpec.TargetType
                                if resourceType == "nat" </span><span class="cov8" title="1">{
                                        natServiceRef := clusterScope.GetNatServiceRef()
                                        clusterScope.Info("### Get Nat ###", "Nat", natServiceRef.ResourceMap)
                                        if len(natServiceRef.ResourceMap) == 0 </span><span class="cov8" title="1">{
                                                natRouteTable = true
                                        }</span>
                                }
                        }
                        <span class="cov8" title="1">if natRouteTable </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">clusterScope.Info("Create the desired routetable", "routeTableName", routeTableName)
                        routeTable, err := routeTableSvc.CreateRouteTable(netId, routeTableName)
                        if err != nil </span><span class="cov8" title="1">{
                                return reconcile.Result{}, fmt.Errorf("%w Can not create routetable for Osccluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
                        }</span>

                        <span class="cov8" title="1">routeTableId := routeTable.GetRouteTableId()
                        clusterScope.Info("Link the desired routetable with subnet", "routeTableName", routeTableName)
                        linkRouteTableId, err := routeTableSvc.LinkRouteTable(routeTableId, subnetId)
                        if err != nil </span><span class="cov8" title="1">{
                                return reconcile.Result{}, fmt.Errorf("%w Can not link routetable with net for Osccluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
                        }</span>
                        <span class="cov8" title="1">clusterScope.Info("### Get routeTable ###", "routeTable", routeTable)
                        routeTablesRef.ResourceMap[routeTableName] = routeTableId
                        routeTableSpec.ResourceID = routeTableId
                        linkRouteTablesRef.ResourceMap[routeTableName] = linkRouteTableId

                        for _, routeSpec := range *routesSpec </span><span class="cov8" title="1">{
                                clusterScope.Info("Set route")
                                clusterScope.Info("Create route for the desired routetable", "routeTableName", routeTableName)
                                _, err = reconcileRoute(ctx, clusterScope, routeSpec, routeTableName, routeTableSvc)
                                if err != nil </span><span class="cov8" title="1">{
                                        return reconcile.Result{}, err
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return reconcile.Result{}, nil</span>
}

// reconcileDeleteRouteTable reconcile the destruction of the RouteTable of the cluster.
func reconcileDeleteRouteTable(ctx context.Context, clusterScope *scope.ClusterScope, routeTableSvc security.OscRouteTableInterface) (reconcile.Result, error) <span class="cov8" title="1">{
        clusterScope.Info("Delete RouteTable")
        var routeTablesSpec []*infrastructurev1beta1.OscRouteTable
        networkSpec := clusterScope.GetNetwork()

        if networkSpec.RouteTables == nil </span><span class="cov8" title="1">{
                networkSpec.SetRouteTableDefaultValue()
                routeTablesSpec = networkSpec.RouteTables
        }</span> else<span class="cov8" title="1"> {
                routeTablesSpec = clusterScope.GetRouteTables()
        }</span>
        <span class="cov8" title="1">routeTablesRef := clusterScope.GetRouteTablesRef()
        linkRouteTablesRef := clusterScope.GetLinkRouteTablesRef()

        netSpec := clusterScope.GetNet()
        netSpec.SetDefaultValue()
        netName := netSpec.Name + "-" + clusterScope.GetUID()
        netId, err := getNetResourceID(netName, clusterScope)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>

        <span class="cov8" title="1">routeTableIds, err := routeTableSvc.GetRouteTableIdsFromNetIds(netId)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>

        <span class="cov8" title="1">osccluster := clusterScope.OscCluster
        for _, routeTableSpec := range routeTablesSpec </span><span class="cov8" title="1">{
                routeTableName := routeTableSpec.Name + "-" + clusterScope.GetUID()
                routeTableId := routeTablesRef.ResourceMap[routeTableName]
                clusterScope.Info("### delete routeTable Id ###", "routeTable", routeTableId)

                if !Contains(routeTableIds, routeTableId) </span><span class="cov8" title="1">{
                        clusterScope.Info("the desired routeTable does no exist anymore", "routeTableName", routeTableName)
                        controllerutil.RemoveFinalizer(osccluster, "oscclusters.infrastructure.cluster.x-k8s.io")
                        return reconcile.Result{}, nil
                }</span>
                <span class="cov8" title="1">clusterScope.Info("Remove Route")
                routesSpec := clusterScope.GetRoute(routeTableSpec.Name)
                for _, routeSpec := range *routesSpec </span><span class="cov8" title="1">{
                        _, err = reconcileDeleteRoute(ctx, clusterScope, routeSpec, routeTableName, routeTableSvc)
                        if err != nil </span><span class="cov8" title="1">{
                                return reconcile.Result{}, err
                        }</span>
                }
                <span class="cov8" title="1">clusterScope.Info("Unlink the desired routeTable", "routeTableName", routeTableName)
                err = routeTableSvc.UnlinkRouteTable(linkRouteTablesRef.ResourceMap[routeTableName])
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, fmt.Errorf("%w Can not unlink routeTable for Osccluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
                }</span>

                <span class="cov8" title="1">clusterScope.Info("delete the desired routeTable", "routeTableName", routeTableName)
                err = routeTableSvc.DeleteRouteTable(routeTablesRef.ResourceMap[routeTableName])
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, fmt.Errorf("%w Can not delete routeTable for Osccluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
                }</span>
        }
        <span class="cov8" title="1">return reconcile.Result{}, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"
        "fmt"
        "io"
        "strings"
        "time"

        "github.com/Jeffail/gabs"
        "github.com/benbjohnson/clock"
        infrastructurev1beta1 "github.com/outscale-dev/cluster-api-provider-outscale.git/api/v1beta1"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/scope"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/services/security"
        tag "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/tag"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"
)

// getSecurityGroupResourceID return the SecurityGroupId from the resourceMap base on SecurityGroupName (tag name + cluster object uid)
func getSecurityGroupResourceID(resourceName string, clusterScope *scope.ClusterScope) (string, error) <span class="cov8" title="1">{
        securityGroupRef := clusterScope.GetSecurityGroupsRef()
        if securityGroupId, ok := securityGroupRef.ResourceMap[resourceName]; ok </span><span class="cov8" title="1">{
                return securityGroupId, nil
        }</span> else<span class="cov8" title="1"> {
                return "", fmt.Errorf("%s does not exist", resourceName)
        }</span>
}

// getSecurityGroupRulesResourceID return the SecurityGroupId from the resourceMap base on SecurityGroupRuleName (tag name + cluster object uid)
func getSecurityGroupRulesResourceID(resourceName string, clusterScope *scope.ClusterScope) (string, error) <span class="cov8" title="1">{
        securityGroupRuleRef := clusterScope.GetSecurityGroupRuleRef()
        if securityGroupRuleId, ok := securityGroupRuleRef.ResourceMap[resourceName]; ok </span><span class="cov8" title="1">{
                return securityGroupRuleId, nil
        }</span> else<span class="cov8" title="1"> {
                return "", fmt.Errorf("%s does not exist", resourceName)
        }</span>
}

// checkSecurityGroupOscDuplicateName check that there are not the same name for securityGroup
func checkSecurityGroupOscDuplicateName(clusterScope *scope.ClusterScope) error <span class="cov8" title="1">{
        var resourceNameList []string
        clusterScope.Info("check unique security group rule")
        securityGroupsSpec := clusterScope.GetSecurityGroups()
        for _, securityGroupSpec := range securityGroupsSpec </span><span class="cov8" title="1">{
                resourceNameList = append(resourceNameList, securityGroupSpec.Name)
        }</span>
        <span class="cov8" title="1">duplicateResourceErr := alertDuplicate(resourceNameList)
        if duplicateResourceErr != nil </span><span class="cov8" title="1">{
                return duplicateResourceErr
        }</span> else<span class="cov8" title="1"> {
                return nil
        }</span>
}

// checkSecurityGroupRuleOscDuplicateName check that there are not the same name for securityGroupRule
func checkSecurityGroupRuleOscDuplicateName(clusterScope *scope.ClusterScope) error <span class="cov8" title="1">{
        clusterScope.Info("check unique security group rule")
        var resourceNameList []string
        securityGroupsSpec := clusterScope.GetSecurityGroups()
        for _, securityGroupSpec := range securityGroupsSpec </span><span class="cov8" title="1">{
                securityGroupRulesSpec := clusterScope.GetSecurityGroupRule(securityGroupSpec.Name)
                for _, securityGroupRuleSpec := range *securityGroupRulesSpec </span><span class="cov8" title="1">{
                        resourceNameList = append(resourceNameList, securityGroupRuleSpec.Name)
                }</span>
                <span class="cov8" title="1">duplicateResourceErr := alertDuplicate(resourceNameList)
                if duplicateResourceErr != nil </span><span class="cov8" title="1">{
                        return duplicateResourceErr
                }</span> else<span class="cov8" title="1"> {
                        return nil
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// checkSecurityGroupFormatParameters check securityGroup parameters format (Tag format, cidr format, ..)
func checkSecurityGroupFormatParameters(clusterScope *scope.ClusterScope) (string, error) <span class="cov8" title="1">{
        clusterScope.Info("Check security group parameters")
        var securityGroupsSpec []*infrastructurev1beta1.OscSecurityGroup
        networkSpec := clusterScope.GetNetwork()
        if networkSpec.SecurityGroups == nil </span><span class="cov8" title="1">{
                networkSpec.SetSecurityGroupDefaultValue()
                securityGroupsSpec = networkSpec.SecurityGroups
        }</span> else<span class="cov8" title="1"> {
                securityGroupsSpec = clusterScope.GetSecurityGroups()
        }</span>
        <span class="cov8" title="1">for _, securityGroupSpec := range securityGroupsSpec </span><span class="cov8" title="1">{
                securityGroupName := securityGroupSpec.Name + "-" + clusterScope.GetUID()
                securityGroupTagName, err := tag.ValidateTagNameValue(securityGroupName)
                if err != nil </span><span class="cov8" title="1">{
                        return securityGroupTagName, err
                }</span>
                <span class="cov8" title="1">securityGroupDescription := securityGroupSpec.Description
                _, err = infrastructurev1beta1.ValidateDescription(securityGroupDescription)
                if err != nil </span><span class="cov8" title="1">{
                        return securityGroupTagName, err
                }</span>
        }
        <span class="cov8" title="1">return "", nil</span>
}

// checkFormatParameters check every securityGroupRule parameters format (Tag format, cidr format, ..)
func checkSecurityGroupRuleFormatParameters(clusterScope *scope.ClusterScope) (string, error) <span class="cov8" title="1">{
        clusterScope.Info("Check security Group rule parameters")
        var securityGroupsSpec []*infrastructurev1beta1.OscSecurityGroup
        networkSpec := clusterScope.GetNetwork()
        if networkSpec.SecurityGroups == nil </span><span class="cov8" title="1">{
                networkSpec.SetSecurityGroupDefaultValue()
                securityGroupsSpec = networkSpec.SecurityGroups
        }</span> else<span class="cov8" title="1"> {
                securityGroupsSpec = clusterScope.GetSecurityGroups()
        }</span>
        <span class="cov8" title="1">for _, securityGroupSpec := range securityGroupsSpec </span><span class="cov8" title="1">{
                securityGroupRulesSpec := clusterScope.GetSecurityGroupRule(securityGroupSpec.Name)
                for _, securityGroupRuleSpec := range *securityGroupRulesSpec </span><span class="cov8" title="1">{
                        securityGroupRuleName := securityGroupRuleSpec.Name + "-" + clusterScope.GetUID()
                        securityGroupRuleTagName, err := tag.ValidateTagNameValue(securityGroupRuleName)
                        if err != nil </span><span class="cov8" title="1">{
                                return securityGroupRuleTagName, err
                        }</span>
                        <span class="cov8" title="1">securityGroupRuleFlow := securityGroupRuleSpec.Flow
                        _, err = infrastructurev1beta1.ValidateFlow(securityGroupRuleFlow)
                        if err != nil </span><span class="cov8" title="1">{
                                return securityGroupRuleTagName, err
                        }</span>
                        <span class="cov8" title="1">securityGroupRuleIPProtocol := securityGroupRuleSpec.IPProtocol
                        _, err = infrastructurev1beta1.ValidateIPProtocol(securityGroupRuleIPProtocol)
                        if err != nil </span><span class="cov8" title="1">{
                                return securityGroupRuleTagName, err
                        }</span>
                        <span class="cov8" title="1">securityGroupRuleIPRange := securityGroupRuleSpec.IPRange
                        _, err = infrastructurev1beta1.ValidateCidr(securityGroupRuleIPRange)
                        if err != nil </span><span class="cov8" title="1">{
                                return securityGroupRuleTagName, err
                        }</span>
                        <span class="cov8" title="1">securityGroupRuleFromPortRange := securityGroupRuleSpec.FromPortRange
                        _, err = infrastructurev1beta1.ValidatePort(securityGroupRuleFromPortRange)
                        if err != nil </span><span class="cov8" title="1">{
                                return securityGroupRuleTagName, err
                        }</span>
                        <span class="cov8" title="1">securityGroupRuleToPortRange := securityGroupRuleSpec.ToPortRange
                        _, err = infrastructurev1beta1.ValidatePort(securityGroupRuleToPortRange)
                        if err != nil </span><span class="cov8" title="1">{
                                return securityGroupRuleTagName, err
                        }</span>

                }
        }
        <span class="cov8" title="1">return "", nil</span>
}

// reconcileSecurityGroupRule reconcile the securityGroupRule of the cluster.
func reconcileSecurityGroupRule(ctx context.Context, clusterScope *scope.ClusterScope, securityGroupRuleSpec infrastructurev1beta1.OscSecurityGroupRule, securityGroupName string, securityGroupSvc security.OscSecurityGroupInterface) (reconcile.Result, error) <span class="cov8" title="1">{

        securityGroupsRef := clusterScope.GetSecurityGroupsRef()
        securityGroupRuleRef := clusterScope.GetSecurityGroupRuleRef()

        securityGroupRuleName := securityGroupRuleSpec.Name + "-" + clusterScope.GetUID()
        if len(securityGroupRuleRef.ResourceMap) == 0 </span><span class="cov8" title="1">{
                securityGroupRuleRef.ResourceMap = make(map[string]string)
        }</span>
        <span class="cov8" title="1">Flow := securityGroupRuleSpec.Flow
        IPProtocol := securityGroupRuleSpec.IPProtocol
        IPRange := securityGroupRuleSpec.IPRange
        FromPortRange := securityGroupRuleSpec.FromPortRange
        ToPortRange := securityGroupRuleSpec.ToPortRange
        associateSecurityGroupId := securityGroupsRef.ResourceMap[securityGroupName]
        clusterScope.Info("### Get associateSecurityGroupId###", "securityGroup", associateSecurityGroupId)
        clusterScope.Info("check if the desired securityGroupRule exist", "securityGroupRuleName", securityGroupRuleName)
        securityGroupFromSecurityGroupRule, err := securityGroupSvc.GetSecurityGroupFromSecurityGroupRule(associateSecurityGroupId, Flow, IPProtocol, IPRange, FromPortRange, ToPortRange)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov8" title="1">if securityGroupFromSecurityGroupRule == nil </span><span class="cov8" title="1">{
                clusterScope.Info("### Create securityGroupRule")
                clusterScope.Info("Create the desired securityGroupRule", "securityGroupRuleName", securityGroupRuleName)
                securityGroupFromSecurityGroupRule, err = securityGroupSvc.CreateSecurityGroupRule(associateSecurityGroupId, Flow, IPProtocol, IPRange, "", FromPortRange, ToPortRange)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, fmt.Errorf("%w Can not create securityGroupRule for OscCluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
                }</span>

        }
        <span class="cov8" title="1">securityGroupRuleRef.ResourceMap[securityGroupRuleName] = securityGroupFromSecurityGroupRule.GetSecurityGroupId()
        return reconcile.Result{}, nil</span>
}

// deleteSecurityGroup reconcile the deletion of securityGroup of the cluster.
func deleteSecurityGroup(ctx context.Context, clusterScope *scope.ClusterScope, securityGroupId string, securityGroupSvc security.OscSecurityGroupInterface, clocktime clock.Clock) (reconcile.Result, error) <span class="cov8" title="1">{
        clusterScope.Info("Check loadbalancer deletion")

        currentTimeout := clocktime.Now().Add(time.Second * 20)
        var loadbalancer_delete = false
        for !loadbalancer_delete </span><span class="cov8" title="1">{
                httpRes, err := securityGroupSvc.DeleteSecurityGroup(securityGroupId)
                if err != nil </span><span class="cov8" title="1">{
                        buffer := new(strings.Builder)
                        _, err := io.Copy(buffer, httpRes.Body)
                        httpResBody := buffer.String()
                        clusterScope.Info("Find body", "httpResBody", httpResBody)
                        httpResBodyData := []byte(httpResBody)
                        httpResBodyParsed, err := gabs.ParseJSON(httpResBodyData)

                        if err != nil </span><span class="cov8" title="1">{
                                return reconcile.Result{}, fmt.Errorf("%w Can not delete securityGroup for Osccluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
                        }</span>
                        <span class="cov8" title="1">httpResCode := strings.Replace(strings.Replace(fmt.Sprintf("%v", httpResBodyParsed.Path("Errors.Code").Data()), "[", "", 1), "]", "", 1)
                        httpResType := strings.Replace(strings.Replace(fmt.Sprintf("%v", httpResBodyParsed.Path("Errors.Type").Data()), "[", "", 1), "]", "", 1)
                        var unexpectedErr bool = true

                        if httpResCode == "9085" &amp;&amp; httpResType == "ResourceConflict" </span><span class="cov8" title="1">{
                                clusterScope.Info("LoadBalancer is not deleting yet")
                                unexpectedErr = false
                        }</span>
                        <span class="cov8" title="1">if unexpectedErr </span><span class="cov8" title="1">{
                                return reconcile.Result{}, fmt.Errorf(" Can not delete securityGroup because of the uncatch error for Osccluster %s/%s", clusterScope.GetNamespace(), clusterScope.GetName())
                        }</span>
                        <span class="cov8" title="1">clusterScope.Info("Wait until loadBalancer is deleting")
                        time.Sleep(5 * time.Second)</span>
                } else<span class="cov8" title="1"> {
                        loadbalancer_delete = true
                }</span>

                <span class="cov8" title="1">if clocktime.Now().After(currentTimeout) </span><span class="cov8" title="1">{
                        return reconcile.Result{}, fmt.Errorf("%w Can not delete securityGroup because to waiting loadbalancer to be delete timeout  for Osccluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
                }</span>

        }
        <span class="cov8" title="1">return reconcile.Result{}, nil</span>
}

// reconcileSecurityGroup reconcile the securityGroup of the cluster.
func reconcileSecurityGroup(ctx context.Context, clusterScope *scope.ClusterScope, securityGroupSvc security.OscSecurityGroupInterface) (reconcile.Result, error) <span class="cov8" title="1">{

        clusterScope.Info("Create SecurityGroup")
        securityGroupsSpec := clusterScope.GetSecurityGroups()

        netSpec := clusterScope.GetNet()
        netSpec.SetDefaultValue()
        netName := netSpec.Name + "-" + clusterScope.GetUID()
        netId, err := getNetResourceID(netName, clusterScope)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>

        <span class="cov8" title="1">clusterScope.Info("Get list of all desired securitygroup in net", "netId", netId)
        securityGroupIds, err := securityGroupSvc.GetSecurityGroupIdsFromNetIds(netId)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov8" title="1">securityGroupsRef := clusterScope.GetSecurityGroupsRef()

        for _, securityGroupSpec := range securityGroupsSpec </span><span class="cov8" title="1">{
                securityGroupName := securityGroupSpec.Name + "-" + clusterScope.GetUID()
                clusterScope.Info("Check if the desired securityGroup exist in net", "securityGroupName", securityGroupName)
                securityGroupDescription := securityGroupSpec.Description
                clusterScope.Info("### Get securityGroup Id ###", "securityGroup", securityGroupIds)
                if len(securityGroupsRef.ResourceMap) == 0 </span><span class="cov8" title="1">{
                        securityGroupsRef.ResourceMap = make(map[string]string)
                }</span>
                <span class="cov8" title="1">if securityGroupSpec.ResourceID != "" </span><span class="cov8" title="1">{
                        securityGroupsRef.ResourceMap[securityGroupName] = securityGroupSpec.ResourceID
                }</span>
                <span class="cov8" title="1">_, resourceMapExist := securityGroupsRef.ResourceMap[securityGroupName]
                if resourceMapExist </span><span class="cov8" title="1">{
                        securityGroupSpec.ResourceID = securityGroupsRef.ResourceMap[securityGroupName]
                }</span>

                <span class="cov8" title="1">securityGroupId := securityGroupsRef.ResourceMap[securityGroupName]
                if !Contains(securityGroupIds, securityGroupId) </span><span class="cov8" title="1">{
                        clusterScope.Info("Find securitygroup", "securityGroup", securityGroupId)
                        clusterScope.Info("Create the desired securitygroup", "securityGroupName", securityGroupName)
                        securityGroup, err := securityGroupSvc.CreateSecurityGroup(netId, securityGroupName, securityGroupDescription)
                        clusterScope.Info("### Get securityGroup", "securityGroup", securityGroup)
                        if err != nil </span><span class="cov8" title="1">{
                                return reconcile.Result{}, fmt.Errorf("%w Can not create securityGroup for Osccluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
                        }</span>
                        <span class="cov8" title="1">securityGroupsRef.ResourceMap[securityGroupName] = *securityGroup.SecurityGroupId
                        securityGroupSpec.ResourceID = *securityGroup.SecurityGroupId

                        clusterScope.Info("check securityGroupRule")
                        securityGroupRulesSpec := clusterScope.GetSecurityGroupRule(securityGroupSpec.Name)
                        for _, securityGroupRuleSpec := range *securityGroupRulesSpec </span><span class="cov8" title="1">{
                                clusterScope.Info("Create securityGroupRule for the desired securityGroup", "securityGroupName", securityGroupName)
                                _, err = reconcileSecurityGroupRule(ctx, clusterScope, securityGroupRuleSpec, securityGroupName, securityGroupSvc)
                                if err != nil </span><span class="cov8" title="1">{
                                        return reconcile.Result{}, err
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return reconcile.Result{}, nil</span>
}

// ReconcileRoute reconcile the RouteTable and the Route of the cluster.
func reconcileDeleteSecurityGroupRule(ctx context.Context, clusterScope *scope.ClusterScope, securityGroupRuleSpec infrastructurev1beta1.OscSecurityGroupRule, securityGroupName string, securityGroupSvc security.OscSecurityGroupInterface) (reconcile.Result, error) <span class="cov8" title="1">{
        osccluster := clusterScope.OscCluster
        securityGroupsRef := clusterScope.GetSecurityGroupsRef()

        securityGroupRuleName := securityGroupRuleSpec.Name + "-" + clusterScope.GetUID()

        Flow := securityGroupRuleSpec.Flow
        IPProtocol := securityGroupRuleSpec.IPProtocol
        IPRange := securityGroupRuleSpec.IPRange
        FromPortRange := securityGroupRuleSpec.FromPortRange
        ToPortRange := securityGroupRuleSpec.ToPortRange
        associateSecurityGroupId := securityGroupsRef.ResourceMap[securityGroupName]
        clusterScope.Info("Delete SecurityGroupRule")
        clusterScope.Info("Check if the desired securityGroupRule exist", "securityGroupRuleName", securityGroupRuleName)
        securityGroupFromSecurityGroupRule, err := securityGroupSvc.GetSecurityGroupFromSecurityGroupRule(associateSecurityGroupId, Flow, IPProtocol, IPRange, FromPortRange, ToPortRange)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov8" title="1">if securityGroupFromSecurityGroupRule == nil </span><span class="cov8" title="1">{
                clusterScope.Info("the desired securityGroupRule does not exist anymore", "securityGroupRuleName", securityGroupRuleName)
                controllerutil.RemoveFinalizer(osccluster, "oscclusters.infrastructure.cluster.x-k8s.io")
                return reconcile.Result{}, nil
        }</span>
        <span class="cov8" title="1">clusterScope.Info("Delete the desired securityGroupRule", "securityGroupRuleName", securityGroupRuleName)
        err = securityGroupSvc.DeleteSecurityGroupRule(associateSecurityGroupId, Flow, IPProtocol, IPRange, "", FromPortRange, ToPortRange)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, fmt.Errorf("%s Can not delete securityGroupRule for OscCluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
        }</span>
        <span class="cov8" title="1">return reconcile.Result{}, nil</span>
}

// reconcileDeleteSecurityGroup reconcile the deletetion of securityGroup of the cluster.
func reconcileDeleteSecurityGroup(ctx context.Context, clusterScope *scope.ClusterScope, securityGroupSvc security.OscSecurityGroupInterface) (reconcile.Result, error) <span class="cov8" title="1">{
        osccluster := clusterScope.OscCluster

        clusterScope.Info("Delete SecurityGroup")
        var securityGroupsSpec []*infrastructurev1beta1.OscSecurityGroup
        networkSpec := clusterScope.GetNetwork()
        if networkSpec.SecurityGroups == nil </span><span class="cov8" title="1">{
                networkSpec.SetSecurityGroupDefaultValue()
                securityGroupsSpec = networkSpec.SecurityGroups
        }</span> else<span class="cov8" title="1"> {
                securityGroupsSpec = clusterScope.GetSecurityGroups()
        }</span>
        <span class="cov8" title="1">securityGroupsRef := clusterScope.GetSecurityGroupsRef()

        netSpec := clusterScope.GetNet()
        netSpec.SetDefaultValue()
        netName := netSpec.Name + "-" + clusterScope.GetUID()
        netId, err := getNetResourceID(netName, clusterScope)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov8" title="1">securityGroupIds, err := securityGroupSvc.GetSecurityGroupIdsFromNetIds(netId)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov8" title="1">clusterScope.Info("Delete SecurityGroup Info")
        clocktime := clock.New()
        for _, securityGroupSpec := range securityGroupsSpec </span><span class="cov8" title="1">{
                securityGroupName := securityGroupSpec.Name + "-" + clusterScope.GetUID()
                securityGroupId := securityGroupsRef.ResourceMap[securityGroupName]
                if !Contains(securityGroupIds, securityGroupId) </span><span class="cov8" title="1">{
                        clusterScope.Info("the desired securityGroup does not exist anymore", "securityGroupName", securityGroupName)
                        controllerutil.RemoveFinalizer(osccluster, "oscclusters.infrastructure.cluster.x-k8s.io")
                        return reconcile.Result{}, nil
                }</span>
                <span class="cov8" title="1">clusterScope.Info("Remove securityGroupRule")
                securityGroupRulesSpec := clusterScope.GetSecurityGroupRule(securityGroupSpec.Name)
                for _, securityGroupRuleSpec := range *securityGroupRulesSpec </span><span class="cov8" title="1">{
                        _, err = reconcileDeleteSecurityGroupRule(ctx, clusterScope, securityGroupRuleSpec, securityGroupName, securityGroupSvc)
                        if err != nil </span><span class="cov8" title="1">{
                                return reconcile.Result{}, err
                        }</span>
                }
                <span class="cov8" title="1">clusterScope.Info("Delete SecurityGroup")
                clusterScope.Info("delete the desired securityGroup", "securityGroupName", securityGroupName)
                _, err := deleteSecurityGroup(ctx, clusterScope, securityGroupsRef.ResourceMap[securityGroupName], securityGroupSvc, clocktime)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, fmt.Errorf("%w Can not delete securityGroup  for Osccluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
                }</span>
        }
        <span class="cov8" title="1">return reconcile.Result{}, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package controllers

import (
        "context"
        "fmt"

        infrastructurev1beta1 "github.com/outscale-dev/cluster-api-provider-outscale.git/api/v1beta1"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/scope"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/services/net"
        tag "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/tag"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"
)

// getSubnetResourceID return the subnetId from the resourceMap base on subnetName (tag name + cluster object uid)
func getSubnetResourceID(resourceName string, clusterScope *scope.ClusterScope) (string, error) <span class="cov8" title="1">{
        subnetRef := clusterScope.GetSubnetRef()
        if subnetId, ok := subnetRef.ResourceMap[resourceName]; ok </span><span class="cov8" title="1">{
                return subnetId, nil
        }</span> else<span class="cov8" title="1"> {
                return "", fmt.Errorf("%s does not exist", resourceName)
        }</span>
}

// checkSubnetFormatParameters check Subnet parameters format (Tag format, cidr format, ..)
func checkSubnetFormatParameters(clusterScope *scope.ClusterScope) (string, error) <span class="cov8" title="1">{
        clusterScope.Info("Check subnet name parameters")
        var subnetsSpec []*infrastructurev1beta1.OscSubnet
        networkSpec := clusterScope.GetNetwork()
        if networkSpec.Subnets == nil </span><span class="cov8" title="1">{
                networkSpec.SetSubnetDefaultValue()
                subnetsSpec = networkSpec.Subnets
        }</span> else<span class="cov8" title="1"> {
                subnetsSpec = clusterScope.GetSubnet()
        }</span>
        <span class="cov8" title="1">for _, subnetSpec := range subnetsSpec </span><span class="cov8" title="1">{
                subnetName := subnetSpec.Name + "-" + clusterScope.GetUID()
                subnetTagName, err := tag.ValidateTagNameValue(subnetName)
                if err != nil </span><span class="cov8" title="1">{
                        return subnetTagName, err
                }</span>
                <span class="cov8" title="1">clusterScope.Info("Check Subnet IpsubnetRange parameters")
                subnetIpRange := subnetSpec.IPSubnetRange
                _, err = infrastructurev1beta1.ValidateCidr(subnetIpRange)
                if err != nil </span><span class="cov8" title="1">{
                        return subnetTagName, err
                }</span>
        }
        <span class="cov8" title="1">return "", nil</span>

}

// checkSubnetOscDuplicateName check that there are not the same name for subnet
func checkSubnetOscDuplicateName(clusterScope *scope.ClusterScope) error <span class="cov8" title="1">{
        var resourceNameList []string
        clusterScope.Info("Check unique subnet")
        subnetsSpec := clusterScope.GetSubnet()
        for _, subnetSpec := range subnetsSpec </span><span class="cov8" title="1">{
                resourceNameList = append(resourceNameList, subnetSpec.Name)
        }</span>
        <span class="cov8" title="1">duplicateResourceErr := alertDuplicate(resourceNameList)
        if duplicateResourceErr != nil </span><span class="cov8" title="1">{
                return duplicateResourceErr
        }</span> else<span class="cov8" title="1"> {
                return nil
        }</span>
}

// reconcileSubnet reconcile the subnet of the cluster.
func reconcileSubnet(ctx context.Context, clusterScope *scope.ClusterScope, subnetSvc net.OscSubnetInterface) (reconcile.Result, error) <span class="cov8" title="1">{
        clusterScope.Info("Create Subnet")

        netSpec := clusterScope.GetNet()
        netSpec.SetDefaultValue()
        netName := netSpec.Name + "-" + clusterScope.GetUID()
        netId, err := getNetResourceID(netName, clusterScope)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov8" title="1">var subnetsSpec []*infrastructurev1beta1.OscSubnet
        subnetsSpec = clusterScope.GetSubnet()

        subnetRef := clusterScope.GetSubnetRef()
        clusterScope.Info("Check if the desired subnet exist")
        clusterScope.Info("### Get subnetId ###", "subnet", subnetRef.ResourceMap)
        var subnetIds []string
        subnetIds, err = subnetSvc.GetSubnetIDsFromNetIds(netId)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov8" title="1">for _, subnetSpec := range subnetsSpec </span><span class="cov8" title="1">{
                subnetName := subnetSpec.Name + "-" + clusterScope.GetUID()
                subnetId := subnetSpec.ResourceID
                if len(subnetRef.ResourceMap) == 0 </span><span class="cov8" title="1">{
                        subnetRef.ResourceMap = make(map[string]string)
                }</span>
                <span class="cov8" title="1">if subnetSpec.ResourceID != "" </span><span class="cov8" title="1">{
                        subnetRef.ResourceMap[subnetName] = subnetSpec.ResourceID
                }</span>
                <span class="cov8" title="1">_, resourceMapExist := subnetRef.ResourceMap[subnetName]
                if resourceMapExist </span><span class="cov8" title="1">{
                        subnetSpec.ResourceID = subnetRef.ResourceMap[subnetName]
                }</span>
                <span class="cov8" title="1">clusterScope.Info("### Get subnetIds ###", "subnetIds", subnetIds)
                clusterScope.Info("### Get subnetId ###", "subnetId", subnetId)
                if !Contains(subnetIds, subnetId) </span><span class="cov8" title="1">{
                        clusterScope.Info("Create the desired subnet", "subnetName", subnetName)
                        subnet, err := subnetSvc.CreateSubnet(subnetSpec, netId, subnetName)
                        if err != nil </span><span class="cov8" title="1">{
                                return reconcile.Result{}, fmt.Errorf("%w Can not create subnet for Osccluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
                        }</span>
                        <span class="cov8" title="1">clusterScope.Info("### Get subnet ###", "subnet", subnet)
                        subnetRef.ResourceMap[subnetName] = subnet.GetSubnetId()
                        subnetSpec.ResourceID = subnet.GetSubnetId()</span>
                }
        }
        <span class="cov8" title="1">return reconcile.Result{}, nil</span>
}

// reconcileDeleteSubnet reconcile the destruction of the Subnet of the cluster.
func reconcileDeleteSubnet(ctx context.Context, clusterScope *scope.ClusterScope, subnetSvc net.OscSubnetInterface) (reconcile.Result, error) <span class="cov8" title="1">{
        osccluster := clusterScope.OscCluster

        clusterScope.Info("Delete subnet")

        subnetsSpec := clusterScope.GetSubnet()
        netSpec := clusterScope.GetNet()
        netSpec.SetDefaultValue()
        netName := netSpec.Name + "-" + clusterScope.GetUID()

        networkSpec := clusterScope.GetNetwork()
        if networkSpec.Subnets == nil </span><span class="cov8" title="1">{
                networkSpec.SetSubnetDefaultValue()
                subnetsSpec = networkSpec.Subnets
        }</span> else<span class="cov8" title="1"> {
                subnetsSpec = clusterScope.GetSubnet()
        }</span>
        <span class="cov8" title="1">netId, err := getNetResourceID(netName, clusterScope)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov8" title="1">subnetIds, err := subnetSvc.GetSubnetIDsFromNetIds(netId)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov8" title="1">for _, subnetSpec := range subnetsSpec </span><span class="cov8" title="1">{
                subnetId := subnetSpec.ResourceID
                subnetName := subnetSpec.Name + "-" + clusterScope.GetUID()
                if !Contains(subnetIds, subnetId) </span><span class="cov8" title="1">{
                        clusterScope.Info("the desired subnet does not exist anymore", "subnetName", subnetName)
                        controllerutil.RemoveFinalizer(osccluster, "oscclusters.infrastructure.cluster.x-k8s.io")
                        return reconcile.Result{}, nil
                }</span>
                <span class="cov8" title="1">err = subnetSvc.DeleteSubnet(subnetId)
                if err != nil </span><span class="cov8" title="1">{
                        clusterScope.Info("Delete te desired subnet", "subnetName", subnetName)
                        return reconcile.Result{}, fmt.Errorf("%w Can not delete subnet for Osccluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
                }</span>
        }
        <span class="cov8" title="1">return reconcile.Result{}, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"
        "fmt"
        "time"

        infrastructurev1beta1 "github.com/outscale-dev/cluster-api-provider-outscale.git/api/v1beta1"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/scope"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/services/compute"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/services/security"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/services/service"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/services/storage"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/util/reconciler"
        "github.com/pkg/errors"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/client-go/tools/record"
        clusterv1 "sigs.k8s.io/cluster-api/api/v1beta1"
        capierrors "sigs.k8s.io/cluster-api/errors"
        "sigs.k8s.io/cluster-api/util"
        "sigs.k8s.io/cluster-api/util/annotations"
        "sigs.k8s.io/cluster-api/util/conditions"
        "sigs.k8s.io/cluster-api/util/predicates"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/builder"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/controller"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
        "sigs.k8s.io/controller-runtime/pkg/handler"
        "sigs.k8s.io/controller-runtime/pkg/log"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"
        "sigs.k8s.io/controller-runtime/pkg/source"
)

// OscMachineReconciler reconciles a OscMachine object
type OscMachineReconciler struct {
        client.Client
        Recorder         record.EventRecorder
        ReconcileTimeout time.Duration
}

//+kubebuilder:rbac:groups=infrastructure.cluster.x-k8s.io,resources=oscmachines,verbs=get;list;watch;create;update;patch;delete
//+kubebuilder:rbac:groups=infrastructure.cluster.x-k8s.io,resources=oscmachines/status,verbs=get;update;patch
//+kubebuilder:rbac:groups=infrastructure.cluster.x-k8s.io,resources=oscmachines/finalizers,verbs=update
//+kubebuilder:rbac:groups=cluster.x-k8s.io,resources=machines,verbs=get;list;watch
//+kubebuilder:rbac:groups=cluster.x-k8s.io,resources=machines/status,verbs=get;list;watch

// Reconcile is part of the main kubernetes reconciliation loop which aims to
// move the current state of the cluster closer to the desired state.
// TODO(user): Modify the Reconcile function to compare the state specified by
// the OscMachine object against the actual cluster state, and then
// perform operations to make the cluster state reflect the state specified by
// the user.
//
// For more details, check Reconcile and its Result here:
// - https://pkg.go.dev/sigs.k8s.io/controller-runtime@v0.11.0/pkg/reconcile

// getVolumeSvc retrieve volumeSvc
func (r *OscMachineReconciler) getVolumeSvc(ctx context.Context, scope scope.ClusterScope) storage.OscVolumeInterface <span class="cov0" title="0">{
        return storage.NewService(ctx, &amp;scope)
}</span>

// getVmSvc retrieve vmSvc
func (r *OscMachineReconciler) getVmSvc(ctx context.Context, scope scope.ClusterScope) compute.OscVMInterface <span class="cov0" title="0">{
        return compute.NewService(ctx, &amp;scope)
}</span>

// getPublicIpSvc retrieve publicIpSvc
func (r *OscMachineReconciler) getPublicIpSvc(ctx context.Context, scope scope.ClusterScope) security.OscPublicIPInterface <span class="cov0" title="0">{
        return security.NewService(ctx, &amp;scope)
}</span>

// getSecurityGroupSvc retrieve securityGroupSvc
func (r *OscMachineReconciler) getSecurityGroupSvc(ctx context.Context, scope scope.ClusterScope) security.OscSecurityGroupInterface <span class="cov0" title="0">{
        return security.NewService(ctx, &amp;scope)
}</span>

// getLoadBalancerSvc retrieve loadBalancerSvc
func (r *OscMachineReconciler) getLoadBalancerSvc(ctx context.Context, scope scope.ClusterScope) service.OscLoadBalancerInterface <span class="cov0" title="0">{
        return service.NewService(ctx, &amp;scope)
}</span>

func (r *OscMachineReconciler) Reconcile(ctx context.Context, req ctrl.Request) (_ ctrl.Result, reterr error) <span class="cov0" title="0">{
        _ = log.FromContext(ctx)
        ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultedLoopTimeout(r.ReconcileTimeout))
        defer cancel()

        log := ctrl.LoggerFrom(ctx)

        oscMachine := &amp;infrastructurev1beta1.OscMachine{}
        if err := r.Get(ctx, req.NamespacedName, oscMachine); err != nil </span><span class="cov0" title="0">{
                if apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        return reconcile.Result{}, nil
                }</span>
                <span class="cov0" title="0">return reconcile.Result{}, err</span>
        }
        <span class="cov0" title="0">machine, err := util.GetOwnerMachine(ctx, r.Client, oscMachine.ObjectMeta)
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, err
        }</span>

        <span class="cov0" title="0">if machine == nil </span><span class="cov0" title="0">{
                log.Info("Machine Controller has not yet set OwnRef")
                return reconcile.Result{}, nil
        }</span>

        <span class="cov0" title="0">cluster, err := util.GetClusterFromMetadata(ctx, r.Client, machine.ObjectMeta)
        if err != nil </span><span class="cov0" title="0">{
                log.Info("Machine is missing cluster label or cluster does not exist")
                return reconcile.Result{}, nil
        }</span>

        <span class="cov0" title="0">log = log.WithValues("machine", machine.Name)
        oscCluster := &amp;infrastructurev1beta1.OscCluster{}
        oscClusterNamespacedName := client.ObjectKey{
                Namespace: oscMachine.Namespace,
                Name:      cluster.Spec.InfrastructureRef.Name,
        }

        if err := r.Get(ctx, oscClusterNamespacedName, oscCluster); err != nil </span><span class="cov0" title="0">{
                log.Info("OscCluster is not available yet")
                return reconcile.Result{}, nil
        }</span>
        <span class="cov0" title="0">if annotations.IsPaused(cluster, oscCluster) </span><span class="cov0" title="0">{
                log.Info("OscMachine or linked Cluster is marked as paused. Won't reconcile")
                return reconcile.Result{}, nil
        }</span>

        <span class="cov0" title="0">clusterScope, err := scope.NewClusterScope(scope.ClusterScopeParams{
                Client:     r.Client,
                Logger:     log,
                Cluster:    cluster,
                OscCluster: oscCluster,
        })
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov0" title="0">machineScope, err := scope.NewMachineScope(scope.MachineScopeParams{
                Logger:     log,
                Client:     r.Client,
                Cluster:    cluster,
                Machine:    machine,
                OscCluster: oscCluster,
                OscMachine: oscMachine,
        })
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, errors.Errorf("failed to create scope: %+v", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := machineScope.Close(); err != nil &amp;&amp; reterr == nil </span><span class="cov0" title="0">{
                        reterr = err
                }</span>
        }()
        <span class="cov0" title="0">if !oscMachine.ObjectMeta.DeletionTimestamp.IsZero() </span><span class="cov0" title="0">{
                return r.reconcileDelete(ctx, machineScope, clusterScope)
        }</span>
        <span class="cov0" title="0">return r.reconcile(ctx, machineScope, clusterScope)</span>
}

// reconcile reconcile the creation of the machine
func (r *OscMachineReconciler) reconcile(ctx context.Context, machineScope *scope.MachineScope, clusterScope *scope.ClusterScope) (reconcile.Result, error) <span class="cov0" title="0">{
        machineScope.Info("Reconciling OscMachine")
        oscmachine := machineScope.OscMachine
        if oscmachine.Status.FailureReason != nil || oscmachine.Status.FailureMessage != nil </span><span class="cov0" title="0">{
                machineScope.Info("Error state detected, skipping reconciliation")
                return reconcile.Result{}, nil
        }</span>

        <span class="cov0" title="0">controllerutil.AddFinalizer(oscmachine, "oscmachine.infrastructure.cluster.x-k8s.io")

        machineScope.Info("Set OscMachine status to not ready")
        machineScope.SetNotReady()
        if !machineScope.Cluster.Status.InfrastructureReady </span><span class="cov0" title="0">{
                machineScope.Info("Cluster infrastructure is not ready yet")
                conditions.MarkFalse(oscmachine, infrastructurev1beta1.VMReadyCondition, infrastructurev1beta1.WaitingForClusterInfrastructureReason, clusterv1.ConditionSeverityInfo, "")
                return ctrl.Result{}, nil
        }</span>
        <span class="cov0" title="0">machineScope.Info("Check bootstrap data")
        if machineScope.Machine.Spec.Bootstrap.DataSecretName == nil </span><span class="cov0" title="0">{
                machineScope.Info("Bootstrap data secret reference is not yet availablle")
                return ctrl.Result{}, nil
        }</span>
        <span class="cov0" title="0">volumeName, err := checkVolumeFormatParameters(machineScope)
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, fmt.Errorf("%w Can not create volume %s for OscMachine %s/%s", err, volumeName, machineScope.GetNamespace(), machineScope.GetName())
        }</span>

        <span class="cov0" title="0">vmName, err := checkVMFormatParameters(machineScope, clusterScope)
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, fmt.Errorf("%w Can not create vm %s for OscMachine %s/%s", err, vmName, machineScope.GetNamespace(), machineScope.GetName())
        }</span>

        <span class="cov0" title="0">duplicateResourceVolumeErr := checkVolumeOscDuplicateName(machineScope)
        if duplicateResourceVolumeErr != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, duplicateResourceVolumeErr
        }</span>

        <span class="cov0" title="0">duplicateResourceVmPrivateIpErr := checkVMPrivateIPOscDuplicateName(machineScope)
        if duplicateResourceVmPrivateIpErr != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, duplicateResourceVmPrivateIpErr
        }</span>

        <span class="cov0" title="0">checkOscAssociateVmVolumeErr := checkVMVolumeOscAssociateResourceName(machineScope)
        if checkOscAssociateVmVolumeErr != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, checkOscAssociateVmVolumeErr
        }</span>

        <span class="cov0" title="0">checkOscAssociateVmSecurityGroupErr := checkVMSecurityGroupOscAssociateResourceName(machineScope, clusterScope)
        if checkOscAssociateVmSecurityGroupErr != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, checkOscAssociateVmSecurityGroupErr
        }</span>

        <span class="cov0" title="0">checkOscAssociateVmSubnetErr := checkVMSubnetOscAssociateResourceName(machineScope, clusterScope)
        if checkOscAssociateVmSubnetErr != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, checkOscAssociateVmSubnetErr
        }</span>

        <span class="cov0" title="0">vmSpec := machineScope.GetVM()
        vmSpec.SetDefaultValue()
        if vmSpec.PublicIPName != "" </span><span class="cov0" title="0">{
                checkOscAssociateVmPublicIpErr := checkVMPublicIPOscAssociateResourceName(machineScope, clusterScope)
                if checkOscAssociateVmPublicIpErr != nil </span><span class="cov0" title="0">{
                        return reconcile.Result{}, checkOscAssociateVmPublicIpErr
                }</span>
        }

        <span class="cov0" title="0">if vmSpec.LoadBalancerName != "" </span><span class="cov0" title="0">{
                checkOscAssociateVmLoadBalancerErr := checkVMLoadBalancerOscAssociateResourceName(machineScope, clusterScope)
                if checkOscAssociateVmLoadBalancerErr != nil </span><span class="cov0" title="0">{
                        return reconcile.Result{}, checkOscAssociateVmLoadBalancerErr
                }</span>
        }

        <span class="cov0" title="0">checkVMVolumeSubregionNameErr := checkVMVolumeSubregionName(machineScope)
        if checkVMVolumeSubregionNameErr != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, checkVMVolumeSubregionNameErr
        }</span>

        <span class="cov0" title="0">volumeSvc := r.getVolumeSvc(ctx, *clusterScope)
        reconcileVolume, err := reconcileVolume(ctx, machineScope, volumeSvc)
        if err != nil </span><span class="cov0" title="0">{
                machineScope.Error(err, "failed to reconcile volume")
                conditions.MarkFalse(oscmachine, infrastructurev1beta1.VolumeReadyCondition, infrastructurev1beta1.VolumeReconciliationFailedReason, clusterv1.ConditionSeverityWarning, err.Error())
                return reconcileVolume, err
        }</span>

        <span class="cov0" title="0">publicIpSvc := r.getPublicIpSvc(ctx, *clusterScope)
        vmSvc := r.getVmSvc(ctx, *clusterScope)
        loadBalancerSvc := r.getLoadBalancerSvc(ctx, *clusterScope)
        securityGroupSvc := r.getSecurityGroupSvc(ctx, *clusterScope)
        reconcileVm, err := reconcileVm(ctx, clusterScope, machineScope, vmSvc, volumeSvc, publicIpSvc, loadBalancerSvc, securityGroupSvc)
        if err != nil </span><span class="cov0" title="0">{
                machineScope.Error(err, "failed to reconcile vm")
                conditions.MarkFalse(oscmachine, infrastructurev1beta1.VMReadyCondition, infrastructurev1beta1.VMNotReadyReason, clusterv1.ConditionSeverityWarning, err.Error())
                return reconcileVm, err
        }</span>
        <span class="cov0" title="0">conditions.MarkTrue(oscmachine, infrastructurev1beta1.VolumeReadyCondition)

        vmState := machineScope.GetVMState()

        switch *vmState </span>{
        case infrastructurev1beta1.VMStatePending:<span class="cov0" title="0">
                machineScope.SetNotReady()
                machineScope.Info("Vm pending", "state", vmState)
                conditions.MarkFalse(oscmachine, infrastructurev1beta1.VMReadyCondition, infrastructurev1beta1.VMNotReadyReason, clusterv1.ConditionSeverityWarning, "")</span>
        case infrastructurev1beta1.VMStateStopping, infrastructurev1beta1.VMStateStopped:<span class="cov0" title="0">
                machineScope.SetNotReady()
                machineScope.Info("Vm stopped", "state", vmState)
                conditions.MarkFalse(oscmachine, infrastructurev1beta1.VMReadyCondition, infrastructurev1beta1.VMStoppedReason, clusterv1.ConditionSeverityWarning, "")</span>
        case infrastructurev1beta1.VMStateRunning:<span class="cov0" title="0">
                machineScope.SetReady()
                machineScope.Info("Vm running", "state", vmState)
                conditions.MarkTrue(oscmachine, infrastructurev1beta1.VMReadyCondition)</span>
        case infrastructurev1beta1.VMStateShuttingDown, infrastructurev1beta1.VMStateTerminated:<span class="cov0" title="0">
                machineScope.SetNotReady()
                machineScope.Info("Unexpected vm termination", "state", vmState)
                conditions.MarkFalse(oscmachine, infrastructurev1beta1.VMReadyCondition, infrastructurev1beta1.VMTerminatedReason, clusterv1.ConditionSeverityError, "")</span>
        default:<span class="cov0" title="0">
                machineScope.SetNotReady()
                machineScope.Info("Vm state is undefined", "state", vmState)
                machineScope.SetFailureReason(capierrors.UpdateMachineError)
                machineScope.SetFailureMessage(errors.Errorf("instance state %+v  is undefined", vmState))
                conditions.MarkUnknown(oscmachine, infrastructurev1beta1.VMReadyCondition, "", "")</span>
        }
        <span class="cov0" title="0">return reconcile.Result{}, nil</span>
}

// reconcileDelete reconcile the deletion of the machine
func (r *OscMachineReconciler) reconcileDelete(ctx context.Context, machineScope *scope.MachineScope, clusterScope *scope.ClusterScope) (reconcile.Result, error) <span class="cov0" title="0">{
        machineScope.Info("Reconciling delete OscMachine")
        oscmachine := machineScope.OscMachine

        volumeSvc := r.getVolumeSvc(ctx, *clusterScope)
        reconcileDeleteVolume, err := reconcileDeleteVolume(ctx, machineScope, volumeSvc)
        if err != nil </span><span class="cov0" title="0">{
                return reconcileDeleteVolume, err
        }</span>
        <span class="cov0" title="0">publicIpSvc := r.getPublicIpSvc(ctx, *clusterScope)
        vmSvc := r.getVmSvc(ctx, *clusterScope)
        loadBalancerSvc := r.getLoadBalancerSvc(ctx, *clusterScope)
        securityGroupSvc := r.getSecurityGroupSvc(ctx, *clusterScope)
        reconcileDeleteVm, err := reconcileDeleteVm(ctx, clusterScope, machineScope, vmSvc, publicIpSvc, loadBalancerSvc, securityGroupSvc)
        if err != nil </span><span class="cov0" title="0">{
                return reconcileDeleteVm, err
        }</span>
        <span class="cov0" title="0">controllerutil.RemoveFinalizer(oscmachine, "oscmachine.infrastructure.cluster.x-k8s.io")
        return reconcile.Result{}, nil</span>
}

// SetupWithManager sets up the controller with the Manager.
func (r *OscMachineReconciler) SetupWithManager(ctx context.Context, mgr ctrl.Manager, options controller.Options) error <span class="cov0" title="0">{
        clusterToObjectFunc, err := util.ClusterToObjectsMapper(r.Client, &amp;infrastructurev1beta1.OscMachineList{}, mgr.GetScheme())
        if err != nil </span><span class="cov0" title="0">{
                return errors.Errorf("failed to create mapper for Cluster to OscMachines: %+v", err)
        }</span>
        <span class="cov0" title="0">err = ctrl.NewControllerManagedBy(mgr).
                For(&amp;infrastructurev1beta1.OscMachine{}).
                Watches(
                        &amp;source.Kind{Type: &amp;clusterv1.Machine{}},
                        handler.EnqueueRequestsFromMapFunc(util.MachineToInfrastructureMapFunc(infrastructurev1beta1.GroupVersion.WithKind("OscMachine"))),
                ).
                Watches(
                        &amp;source.Kind{Type: &amp;infrastructurev1beta1.OscCluster{}},
                        handler.EnqueueRequestsFromMapFunc(r.OscClusterToOscMachines(ctx)),
                ).
                Watches(
                        &amp;source.Kind{Type: &amp;clusterv1.Cluster{}},
                        handler.EnqueueRequestsFromMapFunc(clusterToObjectFunc),
                        builder.WithPredicates(predicates.ClusterUnpausedAndInfrastructureReady(ctrl.LoggerFrom(ctx))),
                ).
                Complete(r)

        if err != nil </span><span class="cov0" title="0">{
                return errors.Errorf("error creating controller: %+v", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// OscClusterToOscMachines convert the cluster to machine spec
func (r *OscMachineReconciler) OscClusterToOscMachines(ctx context.Context) handler.MapFunc <span class="cov0" title="0">{
        return func(o client.Object) []ctrl.Request </span><span class="cov0" title="0">{
                result := []ctrl.Request{}
                log := log.FromContext(ctx)

                c, ok := o.(*infrastructurev1beta1.OscCluster)
                if !ok </span><span class="cov0" title="0">{
                        log.Error(fmt.Errorf("expected a OscCluster but got a %T", o), "failed to get OscMachine for OscCluster")
                        return nil
                }</span>
                <span class="cov0" title="0">log = log.WithValues("objectMapper", "oscClusterToOscMachine", "namespace", c.Namespace, "oscCluster", c.Name)

                if !c.ObjectMeta.DeletionTimestamp.IsZero() </span><span class="cov0" title="0">{
                        log.V(1).Info("OscCluster has a deletion timestamp, skipping mapping.")
                        return nil
                }</span>

                <span class="cov0" title="0">cluster, err := util.GetOwnerCluster(ctx, r.Client, c.ObjectMeta)
                switch </span>{
                case apierrors.IsNotFound(err) || cluster == nil:<span class="cov0" title="0">
                        log.V(1).Info("Cluster for OscCluster not found, skipping mapping.")
                        return result</span>
                case err != nil:<span class="cov0" title="0">
                        log.Error(err, "failed to get owning cluster, skipping mapping.")
                        return result</span>
                }

                <span class="cov0" title="0">labels := map[string]string{clusterv1.ClusterLabelName: cluster.Name}
                machineList := &amp;clusterv1.MachineList{}
                if err := r.List(ctx, machineList, client.InNamespace(c.Namespace), client.MatchingLabels(labels)); err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "failed to list Machines, skipping mapping.")
                        return nil
                }</span>
                <span class="cov0" title="0">for _, m := range machineList.Items </span><span class="cov0" title="0">{
                        log.WithValues("machine", m.Name)
                        if m.Spec.InfrastructureRef.GroupVersionKind().Kind != "OscMachine" </span><span class="cov0" title="0">{
                                log.V(1).Info("Machine has an InfrastructureRef for a different type, will not add to reconcilation request.")
                                continue</span>
                        }
                        <span class="cov0" title="0">if m.Spec.InfrastructureRef.Name == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">name := client.ObjectKey{Namespace: m.Namespace, Name: m.Spec.InfrastructureRef.Name}
                        log.WithValues("oscMachine", name.Name)
                        log.V(1).Info("Adding OscMachine to reconciliation request.")
                        result = append(result, ctrl.Request{NamespacedName: name})</span>
                }
                <span class="cov0" title="0">return result</span>
        }
}
</pre>
		
		<pre class="file" id="file10" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"
        "fmt"
        "strings"

        infrastructurev1beta1 "github.com/outscale-dev/cluster-api-provider-outscale.git/api/v1beta1"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/scope"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/services/compute"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/services/security"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/services/service"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/services/storage"
        tag "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/tag"
        osc "github.com/outscale/osc-sdk-go/v2"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"
)

// getVmResourceId return the vmId from the resourceMap base on resourceName (tag name + cluster uid)
func getVmResourceId(resourceName string, machineScope *scope.MachineScope) (string, error) <span class="cov8" title="1">{
        vmRef := machineScope.GetVMRef()
        if vmId, ok := vmRef.ResourceMap[resourceName]; ok </span><span class="cov8" title="1">{
                return vmId, nil
        }</span> else<span class="cov8" title="1"> {
                return "", fmt.Errorf("%s does not exist", resourceName)
        }</span>
}

// checkVMVolumeOscAssociateResourceName check that Volume dependancies tag name in both resource configuration are the same.
func checkVMVolumeOscAssociateResourceName(machineScope *scope.MachineScope) error <span class="cov8" title="1">{
        var resourceNameList []string
        machineScope.Info("check match volume with vm")
        vmSpec := machineScope.GetVM()
        vmSpec.SetDefaultValue()
        vmVolumeName := vmSpec.VolumeName + "-" + machineScope.GetUID()
        volumesSpec := machineScope.GetVolume()
        for _, volumeSpec := range volumesSpec </span><span class="cov8" title="1">{
                volumeName := volumeSpec.Name + "-" + machineScope.GetUID()
                resourceNameList = append(resourceNameList, volumeName)
        }</span>
        <span class="cov8" title="1">checkOscAssociate := Contains(resourceNameList, vmVolumeName)
        if checkOscAssociate </span><span class="cov8" title="1">{
                return nil
        }</span> else<span class="cov8" title="1"> {
                return fmt.Errorf("%s volume does not exist in vm", vmVolumeName)
        }</span>
}

// checkVMLoadBalancerOscAssociateResourceName  check that LoadBalancer dependancies tag name in both resource configuration are the same.
func checkVMLoadBalancerOscAssociateResourceName(machineScope *scope.MachineScope, clusterScope *scope.ClusterScope) error <span class="cov8" title="1">{
        var resourceNameList []string
        machineScope.Info("check match loadbalancer with vm")
        vmSpec := machineScope.GetVM()
        vmSpec.SetDefaultValue()
        vmLoadBalancerName := vmSpec.LoadBalancerName + "-" + clusterScope.GetUID()
        loadBalancerSpec := clusterScope.GetLoadBalancer()
        loadBalancerName := loadBalancerSpec.LoadBalancerName + "-" + clusterScope.GetUID()
        machineScope.Info("Get LoadBalancerName", "loadBalancerName", loadBalancerName)
        machineScope.Info("Get VmLoadBalancerName", "vmLoadBalancerName", vmLoadBalancerName)
        machineScope.Info("Get Role", "Role", vmSpec.Role)
        resourceNameList = append(resourceNameList, loadBalancerName)
        checkOscAssociate := Contains(resourceNameList, vmLoadBalancerName)
        if checkOscAssociate </span><span class="cov8" title="1">{
                return nil
        }</span> else<span class="cov8" title="1"> {
                return fmt.Errorf("%s loadBalancer does not exist in vm", vmLoadBalancerName)
        }</span>

}

func checkVMVolumeSubregionName(machineScope *scope.MachineScope) error <span class="cov8" title="1">{
        machineScope.Info("check have the same subregionName for vm and for volume")
        vmSpec := machineScope.GetVM()
        vmSpec.SetDefaultValue()
        vmVolumeName := vmSpec.VolumeName
        volumeSubregionName := machineScope.GetVolumeSubregionName(vmVolumeName)
        vmSubregionName := vmSpec.SubregionName
        vmName := vmSpec.Name
        if vmSubregionName != volumeSubregionName </span><span class="cov8" title="1">{
                return fmt.Errorf("volume %s and vm %s are not in the same subregion %s", vmVolumeName, vmName, vmSubregionName)
        }</span> else<span class="cov8" title="1"> {
                return nil
        }</span>
}

// checkVMSecurityGroupOscAssociateResourceName check that SecurityGroup dependancies tag name in both resource configuration are the same.
func checkVMSecurityGroupOscAssociateResourceName(machineScope *scope.MachineScope, clusterScope *scope.ClusterScope) error <span class="cov8" title="1">{
        var resourceNameList []string
        var vmSecurityGroupNameList []string
        var checkOscAssociate bool
        machineScope.Info("check match securityGroup with vm")
        vmSpec := machineScope.GetVM()
        vmSpec.SetDefaultValue()
        vmSecurityGroups := machineScope.GetVMSecurityGroups()
        for _, vmSecurityGroup := range *vmSecurityGroups </span><span class="cov8" title="1">{
                vmSecurityGroupName := vmSecurityGroup.Name + "-" + clusterScope.GetUID()
                vmSecurityGroupNameList = append(vmSecurityGroupNameList, vmSecurityGroupName)
        }</span>
        <span class="cov8" title="1">securityGroupsSpec := clusterScope.GetSecurityGroups()
        for _, securityGroupSpec := range securityGroupsSpec </span><span class="cov8" title="1">{
                securityGroupName := securityGroupSpec.Name + "-" + clusterScope.GetUID()
                resourceNameList = append(resourceNameList, securityGroupName)
        }</span>
        <span class="cov8" title="1">for _, validateVmSecurityGroupName := range vmSecurityGroupNameList </span><span class="cov8" title="1">{
                checkOscAssociate = Contains(resourceNameList, validateVmSecurityGroupName)
                if !checkOscAssociate </span><span class="cov8" title="1">{
                        return fmt.Errorf("%s securityGroup does not exist in vm", validateVmSecurityGroupName)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// checkVMSubnetOscAssociateResourceName check that Subnet dependancies tag name in both resource configuration are the same.
func checkVMSubnetOscAssociateResourceName(machineScope *scope.MachineScope, clusterScope *scope.ClusterScope) error <span class="cov8" title="1">{
        var resourceNameList []string
        machineScope.Info("check match subnet with vm")
        vmSpec := machineScope.GetVM()
        vmSpec.SetDefaultValue()
        vmSubnetName := vmSpec.SubnetName + "-" + clusterScope.GetUID()
        subnetsSpec := clusterScope.GetSubnet()
        for _, subnetSpec := range subnetsSpec </span><span class="cov8" title="1">{
                subnetName := subnetSpec.Name + "-" + clusterScope.GetUID()
                resourceNameList = append(resourceNameList, subnetName)
        }</span>
        <span class="cov8" title="1">checkOscAssociate := Contains(resourceNameList, vmSubnetName)
        if checkOscAssociate </span><span class="cov8" title="1">{
                return nil
        }</span> else<span class="cov8" title="1"> {
                return fmt.Errorf("%s subnet does not exist in vm", vmSubnetName)
        }</span>
}

// checkVMPublicIPOscAssociateResourceName check that PublicIp dependancies tag name in both resource configuration are the same.
func checkVMPublicIPOscAssociateResourceName(machineScope *scope.MachineScope, clusterScope *scope.ClusterScope) error <span class="cov8" title="1">{
        var resourceNameList []string
        machineScope.Info("check match publicip with vm")
        vmSpec := machineScope.GetVM()
        vmSpec.SetDefaultValue()
        vmPublicIPName := vmSpec.PublicIPName + "-" + clusterScope.GetUID()
        publicIpsSpec := clusterScope.GetPublicIP()
        for _, publicIpSpec := range publicIpsSpec </span><span class="cov8" title="1">{
                publicIpName := publicIpSpec.Name + "-" + clusterScope.GetUID()
                resourceNameList = append(resourceNameList, publicIpName)
        }</span>
        <span class="cov8" title="1">checkOscAssociate := Contains(resourceNameList, vmPublicIPName)
        if checkOscAssociate </span><span class="cov8" title="1">{
                return nil
        }</span> else<span class="cov8" title="1"> {
                return fmt.Errorf("%s publicIp does not exist in vm", vmPublicIPName)
        }</span>
}

// checkVMFormatParameters check Volume parameters format
func checkVMFormatParameters(machineScope *scope.MachineScope, clusterScope *scope.ClusterScope) (string, error) <span class="cov8" title="1">{
        machineScope.Info("Check Vm parameters")
        vmSpec := machineScope.GetVM()
        vmSpec.SetDefaultValue()
        vmName := vmSpec.Name + "-" + machineScope.GetUID()
        vmTagName, err := tag.ValidateTagNameValue(vmName)
        if err != nil </span><span class="cov8" title="1">{
                return vmTagName, err
        }</span>
        <span class="cov8" title="1">vmImageID := vmSpec.ImageID
        _, err = infrastructurev1beta1.ValidateImageID(vmImageID)
        if err != nil </span><span class="cov8" title="1">{
                return vmTagName, err
        }</span>

        <span class="cov8" title="1">vmKeypairName := vmSpec.KeypairName
        _, err = infrastructurev1beta1.ValidateKeypairName(vmKeypairName)
        if err != nil </span><span class="cov8" title="1">{
                return vmTagName, err
        }</span>

        <span class="cov8" title="1">vmType := vmSpec.VMType
        _, err = infrastructurev1beta1.ValidateVMType(vmType)
        if err != nil </span><span class="cov8" title="1">{
                return vmTagName, err
        }</span>

        <span class="cov8" title="1">vmDeviceName := vmSpec.DeviceName
        _, err = infrastructurev1beta1.ValidateDeviceName(vmDeviceName)
        if err != nil </span><span class="cov8" title="1">{
                return vmTagName, err
        }</span>

        <span class="cov8" title="1">vmSubregionName := vmSpec.SubregionName
        _, err = infrastructurev1beta1.ValidateSubregionName(vmSubregionName)
        if err != nil </span><span class="cov8" title="1">{
                return vmTagName, err
        }</span>

        <span class="cov8" title="1">vmSubnetName := vmSpec.SubnetName
        machineScope.Info("Get vmSubnetName", "vmSubnetName", vmSubnetName)
        ipSubnetRange := clusterScope.GetIPSubnetRange(vmSubnetName)
        vmPrivateIps := machineScope.GetVMPrivateIPS()
        var subnetsSpec []*infrastructurev1beta1.OscSubnet
        networkSpec := clusterScope.GetNetwork()
        networkSpec.SetSubnetDefaultValue()
        subnetsSpec = networkSpec.Subnets
        for _, subnetSpec := range subnetsSpec </span><span class="cov8" title="1">{
                subnetName := subnetSpec.Name
                ipSubnetRange := subnetSpec.IPSubnetRange
                machineScope.Info("Get IPSubnetRange", "ipSubnetRange", ipSubnetRange)
                machineScope.Info("Get SubnetName", "subnetName", subnetName)
        }</span>
        <span class="cov8" title="1">for _, vmPrivateIp := range *vmPrivateIps </span><span class="cov8" title="1">{
                privateIp := vmPrivateIp.PrivateIP
                machineScope.Info("### Get Valid IP", "privateIp", privateIp)
                machineScope.Info("### Get Valiid subnet ###", "ipSubnetRange", ipSubnetRange)
                _, err := compute.ValidateIPAddrInCidr(privateIp, ipSubnetRange)
                if err != nil </span><span class="cov8" title="1">{
                        return vmTagName, err
                }</span>
        }

        <span class="cov8" title="1">return "", nil</span>
}

// checkVMPrivateIPOscDuplicateName check that there are not the same name for vm resource
func checkVMPrivateIPOscDuplicateName(machineScope *scope.MachineScope) error <span class="cov8" title="1">{
        machineScope.Info("check unique privateIp")
        var resourceNameList []string
        vmPrivateIps := machineScope.GetVMPrivateIPS()
        for _, vmPrivateIp := range *vmPrivateIps </span><span class="cov8" title="1">{
                privateIpName := vmPrivateIp.Name
                resourceNameList = append(resourceNameList, privateIpName)
        }</span>
        <span class="cov8" title="1">duplicateResourceErr := alertDuplicate(resourceNameList)
        if duplicateResourceErr != nil </span><span class="cov8" title="1">{
                return duplicateResourceErr
        }</span> else<span class="cov8" title="1"> {
                return nil
        }</span>
}

// reconcileVm reconcile the vm of the machine
func reconcileVm(ctx context.Context, clusterScope *scope.ClusterScope, machineScope *scope.MachineScope, vmSvc compute.OscVMInterface, volumeSvc storage.OscVolumeInterface, publicIpSvc security.OscPublicIPInterface, loadBalancerSvc service.OscLoadBalancerInterface, securityGroupSvc security.OscSecurityGroupInterface) (reconcile.Result, error) <span class="cov8" title="1">{
        machineScope.Info("Create Vm")
        vmSpec := machineScope.GetVM()
        vmRef := machineScope.GetVMRef()
        vmName := vmSpec.Name + "-" + machineScope.GetUID()

        volumeName := vmSpec.VolumeName + "-" + machineScope.GetUID()
        volumeId, err := getVolumeResourceID(volumeName, machineScope)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>

        <span class="cov8" title="1">subnetName := vmSpec.SubnetName + "-" + clusterScope.GetUID()
        subnetId, err := getSubnetResourceID(subnetName, clusterScope)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>

        <span class="cov8" title="1">var publicIpId string
        var vmPublicIPName string
        var linkPublicIpRef *infrastructurev1beta1.OscResourceMapReference
        if vmSpec.PublicIPName != "" </span><span class="cov8" title="1">{
                vmPublicIPName = vmSpec.PublicIPName + "-" + clusterScope.GetUID()
                publicIpId, err = getPublicIPResourceID(vmPublicIPName, clusterScope)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, err
                }</span>
                <span class="cov8" title="1">linkPublicIpRef = machineScope.GetLinkPublicIPRef()
                if len(linkPublicIpRef.ResourceMap) == 0 </span><span class="cov8" title="1">{
                        linkPublicIpRef.ResourceMap = make(map[string]string)
                }</span>
        }
        <span class="cov8" title="1">var privateIps []string
        vmPrivateIps := machineScope.GetVMPrivateIPS()
        for _, vmPrivateIp := range *vmPrivateIps </span><span class="cov8" title="1">{
                privateIp := vmPrivateIp.PrivateIP
                privateIps = append(privateIps, privateIp)

        }</span>

        <span class="cov8" title="1">var securityGroupIds []string
        vmSecurityGroups := machineScope.GetVMSecurityGroups()
        for _, vmSecurityGroup := range *vmSecurityGroups </span><span class="cov8" title="1">{
                machineScope.Info("Get vmSecurityGroup", "vmSecurityGroup", vmSecurityGroup)
                securityGroupName := vmSecurityGroup.Name + "-" + clusterScope.GetUID()
                securityGroupId, err := getSecurityGroupResourceID(securityGroupName, clusterScope)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, err
                }</span>
                <span class="cov8" title="1">machineScope.Info("get securityGroupId", "securityGroupId", securityGroupId)
                securityGroupIds = append(securityGroupIds, securityGroupId)</span>
        }

        <span class="cov8" title="1">vmDeviceName := vmSpec.DeviceName

        var vm *osc.Vm
        var vmID string
        if len(vmRef.ResourceMap) == 0 </span><span class="cov8" title="1">{
                vmRef.ResourceMap = make(map[string]string)
        }</span>
        <span class="cov8" title="1">machineScope.Info("### Get ResourceId ###", "resourceId", vmSpec.ResourceID)
        machineScope.Info("### Get ResourceMap ###", "resourceMap", vmRef.ResourceMap)
        if vmSpec.ResourceID != "" </span><span class="cov8" title="1">{
                vmRef.ResourceMap[vmName] = vmSpec.ResourceID
                vmId := vmSpec.ResourceID
                machineScope.Info("Check if the desired vm exist", "vmName", vmName)
                machineScope.Info("### Get VmId ####", "vm", vmRef.ResourceMap)
                vm, err = vmSvc.GetVM(vmId)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, err
                }</span>
                <span class="cov8" title="1">vmState, err := vmSvc.GetVMState(vmId)
                if err != nil </span><span class="cov8" title="1">{
                        machineScope.SetVMState(infrastructurev1beta1.VMState("unknown"))
                        return reconcile.Result{}, fmt.Errorf("%w Can not get vm %s state for OscMachine %s/%s", err, vmId, machineScope.GetNamespace(), machineScope.GetName())
                }</span>
                <span class="cov8" title="1">machineScope.SetVMState(infrastructurev1beta1.VMState(vmState))
                machineScope.Info("Get vm state", "vmState", vmState)</span>
        }
        <span class="cov8" title="1">if vm == nil || vmSpec.ResourceID == "" </span><span class="cov8" title="1">{
                machineScope.Info("Create the desired vm", "vmName", vmName)
                imageId := vmSpec.ImageID
                keypairName := vmSpec.KeypairName
                vmType := vmSpec.VMType
                machineScope.Info("### Info ImageID ###", "imageId", imageId)
                machineScope.Info("### Info keypairName ###", "keypairName", keypairName)
                machineScope.Info("### Info vmType ####", "vmType", vmType)

                vm, err := vmSvc.CreateVM(machineScope, vmSpec, subnetId, securityGroupIds, privateIps, vmName)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, fmt.Errorf("%w Can not create vm for OscMachine %s/%s", err, machineScope.GetNamespace(), machineScope.GetName())
                }</span>

                <span class="cov8" title="1">vmID = vm.GetVmId()
                err = vmSvc.CheckVMState(5, 120, "running", vmID)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, fmt.Errorf("%w Can not get vm %s running for OscMachine %s/%s", err, vmID, machineScope.GetNamespace(), machineScope.GetName())
                }</span>
                <span class="cov8" title="1">machineScope.Info("Vm is running", "vmId", vmID)

                err = volumeSvc.CheckVolumeState(5, 60, "available", volumeId)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, fmt.Errorf("%w Can not get volume %s available for OscMachine %s/%s", err, volumeId, machineScope.GetNamespace(), machineScope.GetName())
                }</span>
                <span class="cov8" title="1">machineScope.Info("Volume is available", "volumeId", volumeId)

                machineScope.SetVMState(infrastructurev1beta1.VMState("pending"))
                err = volumeSvc.LinkVolume(volumeId, vmID, vmDeviceName)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, fmt.Errorf("%w Can not link volume %s with vm %s for OscMachine %s/%s", err, volumeId, vmID, machineScope.GetNamespace(), machineScope.GetName())
                }</span>

                <span class="cov8" title="1">machineScope.Info("Volume is linked", "volumeId", volumeId)
                err = volumeSvc.CheckVolumeState(5, 60, "in-use", volumeId)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, fmt.Errorf("%w Can not get volume %s in use for OscMachine %s/%s", err, volumeId, machineScope.GetNamespace(), machineScope.GetName())
                }</span>
                <span class="cov8" title="1">machineScope.Info("Volume is in-use", "volumeId", volumeId)

                err = vmSvc.CheckVMState(5, 60, "running", vmID)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, fmt.Errorf("%w Can not get vm %s running for OscMachine %s/%s", err, vmID, machineScope.GetNamespace(), machineScope.GetName())
                }</span>
                <span class="cov8" title="1">machineScope.Info("Vm is running again", "vmId", vmID)

                if vmSpec.PublicIPName != "" </span><span class="cov8" title="1">{
                        linkPublicIpId, err := publicIpSvc.LinkPublicIP(publicIpId, vmID)
                        if err != nil </span><span class="cov8" title="1">{
                                return reconcile.Result{}, fmt.Errorf("%w Can not link publicIp  %s with %s for OscCluster %s/%s", err, publicIpId, vmID, machineScope.GetNamespace(), machineScope.GetName())
                        }</span>
                        <span class="cov8" title="1">machineScope.Info("Link public ip", "linkPublicIpId", linkPublicIpId)
                        linkPublicIpRef.ResourceMap[vmPublicIPName] = linkPublicIpId

                        err = vmSvc.CheckVMState(5, 60, "running", vmID)
                        if err != nil </span><span class="cov8" title="1">{
                                return reconcile.Result{}, fmt.Errorf("%w Can not get vm %s running for OscMachine %s/%s", err, vmID, machineScope.GetNamespace(), machineScope.GetName())
                        }</span>
                }
                <span class="cov8" title="1">if vmSpec.LoadBalancerName != "" </span><span class="cov8" title="1">{
                        loadBalancerName := vmSpec.LoadBalancerName
                        vmIds := []string{vmID}
                        err := loadBalancerSvc.LinkLoadBalancerBackendMachines(vmIds, loadBalancerName)
                        if err != nil </span><span class="cov8" title="1">{
                                return reconcile.Result{}, fmt.Errorf("%w Can not link vm %s with loadBalancerName %s for OscCluster %s/%s", err, loadBalancerName, vmID, machineScope.GetNamespace(), machineScope.GetName())
                        }</span>
                        <span class="cov8" title="1">machineScope.Info("Create LoadBalancer Sg")
                        securityGroupsRef := clusterScope.GetSecurityGroupsRef()
                        loadBalancerSpec := clusterScope.GetLoadBalancer()
                        loadBalancerSpec.SetDefaultValue()
                        loadBalancerSecurityGroupName := loadBalancerSpec.SecurityGroupName
                        ipProtocol := strings.ToLower(loadBalancerSpec.Listener.BackendProtocol)
                        machineScope.Info("Get IpProtocol", "IpProtocol", ipProtocol)
                        fromPortRange := loadBalancerSpec.Listener.BackendPort
                        machineScope.Info("Get fromPortRange", "fromPortRange", fromPortRange)
                        toPortRange := loadBalancerSpec.Listener.BackendPort
                        machineScope.Info("Get ToPortRange", "ToPortRange", toPortRange)
                        loadBalancerSecurityGroupClusterScopeName := loadBalancerSecurityGroupName + "-" + clusterScope.GetUID()
                        associateSecurityGroupId := securityGroupsRef.ResourceMap[loadBalancerSecurityGroupClusterScopeName]
                        machineScope.Info("Get sg", "associateSecurityGroupId", associateSecurityGroupId)
                        _, err = securityGroupSvc.CreateSecurityGroupRule(associateSecurityGroupId, "Outbound", ipProtocol, "", securityGroupIds[0], fromPortRange, toPortRange)
                        if err != nil </span><span class="cov8" title="1">{
                                return reconcile.Result{}, fmt.Errorf("%s Can not create outbound securityGroupRule for OscCluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
                        }</span>
                        <span class="cov8" title="1">_, err = securityGroupSvc.CreateSecurityGroupRule(securityGroupIds[0], "Inbound", ipProtocol, "", associateSecurityGroupId, fromPortRange, toPortRange)
                        if err != nil </span><span class="cov8" title="1">{
                                return reconcile.Result{}, fmt.Errorf("%w Can not create inbound securityGroupRule for OscCluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
                        }</span>
                }

                <span class="cov8" title="1">machineScope.Info("#### Get Vm ###", "vm", vm)
                vmRef.ResourceMap[vmName] = vmID
                vmSpec.ResourceID = vmID
                machineScope.SetProviderID(vmID)</span>
        }
        <span class="cov8" title="1">return reconcile.Result{}, nil</span>
}

// reconcileDeleteVm reconcile the destruction of the vm of the machine
func reconcileDeleteVm(ctx context.Context, clusterScope *scope.ClusterScope, machineScope *scope.MachineScope, vmSvc compute.OscVMInterface, publicIpSvc security.OscPublicIPInterface, loadBalancerSvc service.OscLoadBalancerInterface, securityGroupSvc security.OscSecurityGroupInterface) (reconcile.Result, error) <span class="cov8" title="1">{
        oscmachine := machineScope.OscMachine
        machineScope.Info("Delete vm")

        vmSpec := machineScope.GetVM()
        vmSpec.SetDefaultValue()

        vmId := vmSpec.ResourceID
        machineScope.Info("### VmiD ###", "vmId", vmId)
        vmName := vmSpec.Name
        vm, err := vmSvc.GetVM(vmId)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>

        <span class="cov8" title="1">var securityGroupIds []string
        vmSecurityGroups := machineScope.GetVMSecurityGroups()
        for _, vmSecurityGroup := range *vmSecurityGroups </span><span class="cov8" title="1">{
                securityGroupName := vmSecurityGroup.Name + "-" + clusterScope.GetUID()
                securityGroupId, err := getSecurityGroupResourceID(securityGroupName, clusterScope)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, err
                }</span>
                <span class="cov8" title="1">securityGroupIds = append(securityGroupIds, securityGroupId)</span>
        }
        <span class="cov8" title="1">if vm == nil </span><span class="cov8" title="1">{
                machineScope.Info("The desired vm does not exist anymore", "vmName", vmName)
                controllerutil.RemoveFinalizer(oscmachine, "")
                return reconcile.Result{}, nil
        }</span>
        <span class="cov8" title="1">if vmSpec.PublicIPName != "" </span><span class="cov8" title="1">{
                linkPublicIpRef := machineScope.GetLinkPublicIPRef()
                publicIpName := vmSpec.PublicIPName + "-" + clusterScope.GetUID()
                err = vmSvc.CheckVMState(5, 120, "running", vmId)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, fmt.Errorf("%w Can not get vm %s running for OscMachine %s/%s", err, vmId, machineScope.GetNamespace(), machineScope.GetName())
                }</span>
                <span class="cov8" title="1">err = publicIpSvc.UnlinkPublicIP(linkPublicIpRef.ResourceMap[publicIpName])
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, fmt.Errorf("%w Can not unlink publicIp for OscCluster %s/%s", err, machineScope.GetNamespace(), machineScope.GetName())
                }</span>

        }
        <span class="cov8" title="1">if vmSpec.LoadBalancerName != "" </span><span class="cov8" title="1">{
                err = vmSvc.CheckVMState(5, 60, "running", vmId)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, fmt.Errorf("%w Can not get vm %s running for OscMachine %s/%s", err, vmId, machineScope.GetNamespace(), machineScope.GetName())
                }</span>
                <span class="cov8" title="1">vmIds := []string{vmId}
                loadBalancerName := vmSpec.LoadBalancerName
                err := loadBalancerSvc.UnlinkLoadBalancerBackendMachines(vmIds, loadBalancerName)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, fmt.Errorf("%w Can not unlink vm %s with loadBalancerName %s for OscCluster %s/%s", err, loadBalancerName, vmId, machineScope.GetNamespace(), machineScope.GetName())
                }</span>
                <span class="cov8" title="1">machineScope.Info("Delete LoadBalancer sg")
                securityGroupsRef := clusterScope.GetSecurityGroupsRef()
                loadBalancerSpec := clusterScope.GetLoadBalancer()
                loadBalancerSecurityGroupName := loadBalancerSpec.SecurityGroupName
                ipProtocol := strings.ToLower(loadBalancerSpec.Listener.BackendProtocol)
                machineScope.Info("Get IpProtocol", "ipProtocol", ipProtocol)
                fromPortRange := loadBalancerSpec.Listener.BackendPort
                machineScope.Info("Get FromPortRange", "FromPortRange", fromPortRange)
                toPortRange := loadBalancerSpec.Listener.BackendPort
                machineScope.Info("Get ToPortRange", "ToPortRange", toPortRange)
                loadBalancerSecurityGroupClusterScopeName := loadBalancerSecurityGroupName + "-" + clusterScope.GetUID()
                associateSecurityGroupId := securityGroupsRef.ResourceMap[loadBalancerSecurityGroupClusterScopeName]
                machineScope.Info("Get associate", "AssociateSecurityGroupId", associateSecurityGroupId)
                machineScope.Info("Get sg id", "securityGroupIds", securityGroupIds[0])
                err = securityGroupSvc.DeleteSecurityGroupRule(associateSecurityGroupId, "Outbound", ipProtocol, "", securityGroupIds[0], fromPortRange, toPortRange)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, fmt.Errorf("%w Can not delete outbound securityGroupRule for OscCluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
                }</span>
                <span class="cov8" title="1">err = securityGroupSvc.DeleteSecurityGroupRule(securityGroupIds[0], "Inbound", ipProtocol, "", securityGroupIds[0], fromPortRange, toPortRange)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, fmt.Errorf("%w Can not delete inbound securityGroupRule for OscCluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
                }</span>
        }

        <span class="cov8" title="1">err = vmSvc.DeleteVM(vmId)
        machineScope.Info("Delete the desired vm", "vmName", vmName)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, fmt.Errorf("%w Can not delete vm for OscMachine %s/%s", err, machineScope.GetNamespace(), machineScope.GetName())
        }</span>
        <span class="cov8" title="1">return reconcile.Result{}, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"
        "fmt"

        infrastructurev1beta1 "github.com/outscale-dev/cluster-api-provider-outscale.git/api/v1beta1"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/scope"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/services/storage"
        tag "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/tag"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"
)

// getVolumeResourceID return the volumeId from the resourceMap base on resourceName (tag name + cluster uid)
func getVolumeResourceID(resourceName string, machineScope *scope.MachineScope) (string, error) <span class="cov8" title="1">{
        volumeRef := machineScope.GetVolumeRef()
        if volumeId, ok := volumeRef.ResourceMap[resourceName]; ok </span><span class="cov8" title="1">{
                return volumeId, nil
        }</span> else<span class="cov8" title="1"> {
                return "", fmt.Errorf("%s does not exist", resourceName)
        }</span>
}

// checkVolumeOscDuplicateName check that there are not the same name for volume resource
func checkVolumeOscDuplicateName(machineScope *scope.MachineScope) error <span class="cov8" title="1">{
        machineScope.Info("Check unique name volume")
        var resourceNameList []string
        volumesSpec := machineScope.GetVolume()
        for _, volumeSpec := range volumesSpec </span><span class="cov8" title="1">{
                resourceNameList = append(resourceNameList, volumeSpec.Name)
        }</span>
        <span class="cov8" title="1">duplicateResourceErr := alertDuplicate(resourceNameList)
        if duplicateResourceErr != nil </span><span class="cov8" title="1">{
                return duplicateResourceErr
        }</span> else<span class="cov8" title="1"> {
                return nil
        }</span>
}

// checkVolumeFormatParameters check Volume parameters format
func checkVolumeFormatParameters(machineScope *scope.MachineScope) (string, error) <span class="cov8" title="1">{
        machineScope.Info("Check Volumes parameters")
        var volumesSpec []*infrastructurev1beta1.OscVolume
        nodeSpec := machineScope.GetNode()
        if nodeSpec.Volumes == nil </span><span class="cov8" title="1">{
                nodeSpec.SetVolumeDefaultValue()
                volumesSpec = nodeSpec.Volumes
        }</span> else<span class="cov8" title="1"> {
                volumesSpec = machineScope.GetVolume()
        }</span>
        <span class="cov8" title="1">for _, volumeSpec := range volumesSpec </span><span class="cov8" title="1">{

                volumeName := volumeSpec.Name + "-" + machineScope.GetUID()
                volumeTagName, err := tag.ValidateTagNameValue(volumeName)
                if err != nil </span><span class="cov8" title="1">{
                        return volumeTagName, err
                }</span>

                <span class="cov8" title="1">if volumeSpec.Iops != 0 </span><span class="cov8" title="1">{
                        volumeIops := volumeSpec.Iops
                        _, err = infrastructurev1beta1.ValidateIops(volumeIops)
                        if err != nil </span><span class="cov8" title="1">{
                                return volumeTagName, err
                        }</span>
                }

                <span class="cov8" title="1">volumeSize := volumeSpec.Size
                machineScope.Info("Check volume info", "volumeSize", volumeSize)
                _, err = infrastructurev1beta1.ValidateSize(volumeSize)
                if err != nil </span><span class="cov8" title="1">{
                        return volumeTagName, err
                }</span>

                <span class="cov8" title="1">volumeSubregionName := volumeSpec.SubregionName
                _, err = infrastructurev1beta1.ValidateSubregionName(volumeSubregionName)
                if err != nil </span><span class="cov8" title="1">{
                        return volumeTagName, err
                }</span>
                <span class="cov8" title="1">volumeType := volumeSpec.VolumeType
                _, err = infrastructurev1beta1.ValidateVolumeType(volumeType)
                if err != nil </span><span class="cov8" title="1">{
                        return volumeTagName, err
                }</span>
        }
        <span class="cov8" title="1">return "", nil</span>
}

// reconcileVolume reconcile the volume of the machine
func reconcileVolume(ctx context.Context, machineScope *scope.MachineScope, volumeSvc storage.OscVolumeInterface) (reconcile.Result, error) <span class="cov8" title="1">{
        machineScope.Info("Create Volume")

        var volumeId string
        var volumeIds []string
        var volumesSpec []*infrastructurev1beta1.OscVolume
        volumesSpec = machineScope.GetVolume()
        volumeRef := machineScope.GetVolumeRef()
        for _, volumeSpec := range volumesSpec </span><span class="cov8" title="1">{
                volumeId = volumeSpec.ResourceID
                volumeIds = append(volumeIds, volumeId)
        }</span>

        <span class="cov8" title="1">machineScope.Info("Check if the desired volumes exist")
        validVolumeIds, err := volumeSvc.ValidateVolumeIds(volumeIds)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov8" title="1">machineScope.Info("### Check Id ###", "volume", volumeIds)
        for _, volumeSpec := range volumesSpec </span><span class="cov8" title="1">{
                volumeName := volumeSpec.Name + "-" + machineScope.GetUID()
                if len(volumeRef.ResourceMap) == 0 </span><span class="cov8" title="1">{
                        volumeRef.ResourceMap = make(map[string]string)
                }</span>
                <span class="cov8" title="1">if volumeSpec.ResourceID != "" </span><span class="cov8" title="1">{
                        volumeRef.ResourceMap[volumeName] = volumeSpec.ResourceID
                }</span>
                <span class="cov8" title="1">volumeId := volumeRef.ResourceMap[volumeName]
                if !Contains(validVolumeIds, volumeId) </span><span class="cov8" title="1">{
                        volume, err := volumeSvc.CreateVolume(volumeSpec, volumeName)
                        if err != nil </span><span class="cov8" title="1">{
                                return reconcile.Result{}, fmt.Errorf("%w Can not create volume for OscMachine %s/%s", err, machineScope.GetNamespace(), machineScope.GetName())
                        }</span>
                        <span class="cov8" title="1">volumeId := volume.GetVolumeId()
                        machineScope.Info("### Get VolumeId ###", "volumeId", volumeId)
                        if volumeId != "" </span><span class="cov8" title="1">{
                                err = volumeSvc.CheckVolumeState(5, 60, "available", volumeId)
                                if err != nil </span><span class="cov8" title="1">{
                                        return reconcile.Result{}, fmt.Errorf("%w Can not get volume available for OscMachine %s/%s", err, machineScope.GetNamespace(), machineScope.GetName())
                                }</span>
                                <span class="cov8" title="1">machineScope.Info("Volume is available", "volumeId", volumeId)</span>
                        }
                        <span class="cov8" title="1">machineScope.Info("### Get volume ###", "volume", volume)
                        volumeRef.ResourceMap[volumeName] = volume.GetVolumeId()
                        volumeSpec.ResourceID = volume.GetVolumeId()</span>
                }
        }
        <span class="cov8" title="1">return reconcile.Result{}, nil</span>
}

// reconcileDeleteVolume reconcile the destruction of the volume of the machine
func reconcileDeleteVolume(ctx context.Context, machineScope *scope.MachineScope, volumeSvc storage.OscVolumeInterface) (reconcile.Result, error) <span class="cov8" title="1">{
        oscmachine := machineScope.OscMachine

        machineScope.Info("Delete Volume")
        var volumesSpec []*infrastructurev1beta1.OscVolume
        nodeSpec := machineScope.GetNode()
        if nodeSpec.Volumes == nil </span><span class="cov8" title="1">{
                nodeSpec.SetVolumeDefaultValue()
                volumesSpec = nodeSpec.Volumes
        }</span> else<span class="cov8" title="1"> {
                volumesSpec = machineScope.GetVolume()
        }</span>

        <span class="cov8" title="1">var volumeIds []string
        var volumeId string
        for _, volumeSpec := range volumesSpec </span><span class="cov8" title="1">{
                volumeId = volumeSpec.ResourceID
                volumeIds = append(volumeIds, volumeId)
        }</span>
        <span class="cov8" title="1">validVolumeIds, err := volumeSvc.ValidateVolumeIds(volumeIds)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov8" title="1">machineScope.Info("### Check Id ###", "volume", volumeIds)
        for _, volumeSpec := range volumesSpec </span><span class="cov8" title="1">{
                volumeId = volumeSpec.ResourceID
                volumeName := volumeSpec.Name + "-" + machineScope.GetUID()
                if !Contains(validVolumeIds, volumeId) </span><span class="cov8" title="1">{
                        controllerutil.RemoveFinalizer(oscmachine, "")
                        return reconcile.Result{}, nil
                }</span>
                <span class="cov8" title="1">err = volumeSvc.CheckVolumeState(5, 60, "in-use", volumeId)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, fmt.Errorf("%w Can not get volume %s in use for OscMachine %s/%s", err, volumeId, machineScope.GetNamespace(), machineScope.GetName())
                }</span>
                <span class="cov8" title="1">machineScope.Info("Volume is in use", "volumeId", volumeId)

                err = volumeSvc.UnlinkVolume(volumeId)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, fmt.Errorf("%w Can not unlink volume %s in use for OscMachine %s/%s", err, volumeId, machineScope.GetNamespace(), machineScope.GetName())
                }</span>
                <span class="cov8" title="1">machineScope.Info("Volume is unlinked", "volumeId", volumeId)

                err = volumeSvc.CheckVolumeState(5, 60, "available", volumeId)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, fmt.Errorf("%w Can not get volume %s available for OscMachine %s/%s", err, volumeId, machineScope.GetNamespace(), machineScope.GetName())
                }</span>
                <span class="cov8" title="1">machineScope.Info("Volume is available", "volumeId", volumeId)
                machineScope.Info("Remove volume")
                machineScope.Info("Delete the desired volume", "volumeName", volumeName)
                err = volumeSvc.DeleteVolume(volumeId)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, fmt.Errorf("%w Can not delete volume for OscMachine %s/%s", err, machineScope.GetNamespace(), machineScope.GetName())
                }</span>
        }
        <span class="cov8" title="1">return reconcile.Result{}, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
